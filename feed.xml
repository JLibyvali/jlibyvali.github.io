<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jlibyvali.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jlibyvali.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-01T14:38:45+00:00</updated><id>https://jlibyvali.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">MIT6.828/fall 2018 Lab 1</title><link href="https://jlibyvali.github.io/blog/2025/MITLAB1/" rel="alternate" type="text/html" title="MIT6.828/fall 2018 Lab 1"/><published>2025-01-15T20:31:00+00:00</published><updated>2025-01-15T20:31:00+00:00</updated><id>https://jlibyvali.github.io/blog/2025/MITLAB1</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2025/MITLAB1/"><![CDATA[<h1 id="lab1-notes">Lab1 Notes</h1> <h2 id="pre-required">Pre-required</h2> <p>1GBit: 0x40000000(Hex)<br/> 1MBit: 0x100000(Hex)<br/> 1KBit: 0x400(Hex)</p> <blockquote> <p>16-bit Intel 8088 hard-wired memory layout.</p> </blockquote> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0xFFFFFFFF</span> <span class="p">(</span><span class="mi">4</span><span class="n">GB</span><span class="p">)</span>
<span class="o">|</span>      <span class="mi">32</span><span class="o">-</span><span class="n">bit</span>      <span class="o">|</span>
<span class="o">|</span>  <span class="n">memory</span> <span class="n">mapped</span>   <span class="o">|</span>
<span class="o">|</span>     <span class="n">devices</span>      <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span>\

<span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span>\
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>      <span class="n">Unused</span>      <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">amount</span> <span class="n">of</span> <span class="n">RAM</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span> <span class="n">Extended</span> <span class="n">Memory</span>  <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x00100000</span> <span class="p">(</span><span class="mi">1</span><span class="n">MB</span><span class="p">)</span>
<span class="o">|</span>     <span class="n">BIOS</span> <span class="n">ROM</span>     <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x000F0000</span> <span class="p">(</span><span class="mi">960</span><span class="n">KB</span><span class="p">)</span>
<span class="o">|</span>  <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">devices</span><span class="p">,</span> <span class="o">|</span>
<span class="o">|</span>  <span class="n">expansion</span> <span class="n">ROMs</span>  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x000C0000</span> <span class="p">(</span><span class="mi">768</span><span class="n">KB</span><span class="p">)</span>
<span class="o">|</span>   <span class="n">VGA</span> <span class="n">Display</span>    <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x000A0000</span> <span class="p">(</span><span class="mi">640</span><span class="n">KB</span><span class="p">)</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>    <span class="n">Low</span> <span class="n">Memory</span>    <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x00000000</span>  

</code></pre></div></div> <p>Real Mode: BIOS can get control of all machine address after power-up, which is Crucial because non any-software code in RAM can be executed by processor.</p> <h2 id="parts">PARTS</h2> <h3 id="part-i-the-rom-bios">PART I. the ROM BIOS</h3> <p>At GDB First Debug stop, we can know something about real mode.<br/> QEMU places it own BIOS(called SeaBIOS) at the segment address (CS=0xf000:IP=0xfff0) = 0xffff0 physical address.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">[</span><span class="n">f000</span><span class="o">:</span><span class="n">fff0</span><span class="p">]</span> <span class="mh">0xffff0</span><span class="o">:</span>	<span class="n">ljmp</span>   <span class="err">$</span><span class="mh">0xf000</span><span class="p">,</span><span class="err">$</span><span class="mh">0xe05b</span>

<span class="c1">// The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS.</span>
<span class="c1">// The PC starts executing with CS = 0xf000 and IP = 0xfff0.</span>
<span class="c1">// The first instruction to be executed is a jmp instruction, which jumps to the `segmented address` CS = 0xf000 and IP = 0xe05b.  </span>

</code></pre></div></div> <p>So instruction begin at (CS:IP) segment address. And will execute an instruction that <code class="language-plaintext highlighter-rouge">jmp</code> to (CS=0xf000:IP=0xe05b)</p> <p>Intel broke the barrier of 1MB RAM in processor 80286 and 80386. So PC architectures preserved the Origin memory layout to keep backward compatibility. Therefore, modern PC have a <code class="language-plaintext highlighter-rouge">hole</code> in physical memory from <code class="language-plaintext highlighter-rouge">0x000A0000 -&gt; 0x00100000</code>, which dividing the memory into <code class="language-plaintext highlighter-rouge">low memory</code> and <code class="language-plaintext highlighter-rouge">extended memory</code> .</p> <hr/> <ul> <li>Ex.2 Figure out the general idea of what BIOS done.</li> </ul> <blockquote> <p>CPU is in Real-Mode, BIOS sets up an Interrupt Descriptor Table and initialized some devices like VGA. this is the BIOS message <code class="language-plaintext highlighter-rouge">Starting SeaBIOS</code> where com from.<br/> Initialized PCI bus and all important device BIOS know about.<br/> After that, searched all possible bootable devices like a floppy,hard drive, CD-ROM. Then read the <code class="language-plaintext highlighter-rouge">boot loader</code> into RAM.</p> </blockquote> <h3 id="part-ii-boot-loader">PART II. Boot Loader</h3> <p>Hard disk for PCs is divided into 512 bytes region called sector, which is also the disk’s minimum transfer granularity: <code class="language-plaintext highlighter-rouge">read or write operations must be one or more sectors in size and aligned on a sector boundary.</code> <br/> When BIOS find a bootable disk, it will read disk first sector into physical address <code class="language-plaintext highlighter-rouge">0x7c00 - 0x7dff</code>, and use <code class="language-plaintext highlighter-rouge">jmp</code> instruction to set (CS = 0000 : IP = 7c00), passing Machine control to boot loader.</p> <hr/> <p><strong>Read code boot.S, main.c boot.asm</strong></p> <p><strong>Pre-required: read the Makefile and .gdbinit. realize the ELF format, using <code class="language-plaintext highlighter-rouge">readelf</code> and <code class="language-plaintext highlighter-rouge">objdump</code> tool help understand code.</strong></p> <hr/> <blockquote> <p>GNUmakefile:<br/> Top-level makefile, describe the info <code class="language-plaintext highlighter-rouge">make target rule</code>, boot/Makefrag nad kern/Makefrag responsible for compile code.</p> </blockquote> <blockquote> <p>.gdbinit:<br/> When you <code class="language-plaintext highlighter-rouge">make gdb</code> its the configuration file of gdb, connect to QEMU target and run a loop which <code class="language-plaintext highlighter-rouge">translate the segment address to physical address</code> both in processor 16bit and 32bit mode.</p> </blockquote> <blockquote> <p>boot/Makefrag: <br/> Compiling the boot.o main.o boot.out. Link the boot.out(also the bootloader) with ` $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^`</p> </blockquote> <blockquote> <p>kern/Makefrag: <br/> using LD script to linking.</p> </blockquote> <blockquote> <p>boot.S:</p> <ol> <li>Switch the processor from real-mode to 32bit protected mode, because Only in this mode software can access all memory above 1MB in processor’s physical address space. And jmp to <code class="language-plaintext highlighter-rouge">bootmain</code> function. If failed, jumped into a infinite loop.</li> <li>Set the stack pointer for <code class="language-plaintext highlighter-rouge">bootmain</code> function and loading a Bootstrap GDT to make virtual address translate.</li> </ol> </blockquote> <blockquote> <p>main.c:<br/> Read the kernel from IDE disk device via x86’s specific instructions(like <code class="language-plaintext highlighter-rouge">outb</code>, <code class="language-plaintext highlighter-rouge">inb</code>). In details, it reads via a ELF format struct, and call the kernel entry by ELF struct member, i.e. a function pointer. the main.c not returned.</p> </blockquote> <blockquote> <p>boot.asm: <br/> the disassembled code from <code class="language-plaintext highlighter-rouge">boot.out</code> ELF executable file. Reads it with GDB <code class="language-plaintext highlighter-rouge">x /Ni ADDR</code> instruction can help you identify where you are.</p> </blockquote> <hr/> <ul> <li>Ex.3 Using GDB debug the bootloader, examine the progress to kernel.</li> </ul> <p><code class="language-plaintext highlighter-rouge">0x7c00</code> enter the <code class="language-plaintext highlighter-rouge">boot.S</code> program code, and if every thing OK, it will call <code class="language-plaintext highlighter-rouge">bootmain()</code> function at[0x7d19].<br/> the <code class="language-plaintext highlighter-rouge">bootmain()</code> function will read segment-address data to <code class="language-plaintext highlighter-rouge">ELF-HEADER</code> address(0x100000).</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="cp">#define ELFHDR		((struct Elf *) 0x10000) // 1MB address load the kernel.img. and type is `struct Elf`, so can access members by offset. 
</span>	<span class="c1">// and it's a macro, also in disassembled file code.  </span>

	<span class="k">struct</span> <span class="n">Proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>

	<span class="c1">// read 1st page off disk, and `readsect()` is really read function using x86 instructions.  </span>
	<span class="n">readseg</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">ELFHDR</span><span class="p">,</span> <span class="n">SECTSIZE</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="c1">// is this a valid ELF?</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="c1">// load each program segment (ignores ph flags)</span>
	<span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Proghdr</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELFHDR</span> <span class="o">+</span> <span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>
	<span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span>
		<span class="c1">// p_pa is the load address of this segment (as well</span>
		<span class="c1">// as the physical address)</span>
		<span class="n">readseg</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">);</span>
	<span class="cm">/** ASM for-loop 
	7d56:	39 f3                	cmp    %esi,%ebx
    7d58:	73 17                	jae    7d71 &lt;bootmain+0x58&gt;
    7d5a:	50                   	push   %eax
    7d5b:	83 c3 20             	add    $0x20,%ebx
    7d5e:	ff 73 e4             	push   -0x1c(%ebx)
    7d61:	ff 73 f4             	push   -0xc(%ebx)
    7d64:	ff 73 ec             	push   -0x14(%ebx)
    7d67:	e8 6e ff ff ff       	call   7cda &lt;readseg&gt;
    7d6c:	83 c4 10             	add    $0x10,%esp
    7d6f:	eb e5                	jmp    7d56 &lt;bootmain+0x3d&gt;
	 */</span>

	<span class="c1">// call the entry point from the ELF header</span>
	<span class="c1">//ASM     7d71:	ff 15 18 00 01 00    	call   *0x10018</span>
	<span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">))();</span>	

</code></pre></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> At what point does the processor start executing 32-bit code? What exactly causes the switch from 16-bit to 32-bit mode?</p> </blockquote> <p>In <code class="language-plaintext highlighter-rouge">boot.S</code> code <code class="language-plaintext highlighter-rouge">seta20.2</code> label, the instructions <code class="language-plaintext highlighter-rouge">.code32</code> made this conversion happened.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</p> </blockquote> <p>The last instruction of boot loader is in <code class="language-plaintext highlighter-rouge">boot/main.c</code>, instruction: ` 7d71: ff 15 18 00 01 00 call *0x10018 <code class="language-plaintext highlighter-rouge">. The first instruction of kernel is in </code>kern/entry.S`, the instruction:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nl">entry:</span>
	<span class="n">movw</span>	<span class="err">$</span><span class="mh">0x1234</span><span class="p">,</span><span class="mh">0x472</span>			<span class="err">#</span> <span class="n">warm</span> <span class="n">boot</span>  
</code></pre></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> Where is the first instruction of the kernel?</p> </blockquote> <p>In kern/entry.S</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p> </blockquote> <p>Using ELF header struct members. First read a page size memory to address[0x100000] with the struct Elf type. then access struct Elf to get the ELF file end page offset. Then using <code class="language-plaintext highlighter-rouge">readsegt()</code> function to read correct num sectors.</p> <h4 id="loading-kernel">Loading Kernel</h4> <hr/> <p>In this sections, using the <code class="language-plaintext highlighter-rouge">objdump</code> to read <code class="language-plaintext highlighter-rouge">obj/kern/kern and obj/boot/boot.out</code> various header tale information. See wiki to know ELF format and its tables <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a>.<br/> <code class="language-plaintext highlighter-rouge">objdump -h </code> read the ELF file section table, it contains all section in this ELF file.</p> <p>Like:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Idx</span> <span class="n">Name</span>          <span class="n">Size</span>      <span class="n">VMA</span>       <span class="n">LMA</span>       <span class="n">File</span> <span class="n">off</span>  <span class="n">Algn</span>
  <span class="mi">1</span> <span class="p">.</span><span class="n">text</span>         <span class="mo">000001</span><span class="mi">8</span><span class="n">c</span>  <span class="mo">00007</span><span class="n">c00</span>  <span class="mo">00007</span><span class="n">c00</span>  <span class="mo">000000</span><span class="n">d4</span>  <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
                  <span class="n">CONTENTS</span><span class="p">,</span> <span class="n">ALLOC</span><span class="p">,</span> <span class="n">LOAD</span><span class="p">,</span> <span class="n">CODE</span>

</code></pre></div></div> <p>VMA(link address) is the address from which section expected to executed, LMA(load address) is the memory address which section wanna be loaded into memory.</p> <p>The linker encodes the link address in the binary in various ways, such as when the code needs the <code class="language-plaintext highlighter-rouge">address of a global variable</code>, with the result that a binary usually won’t work if it is executing from an address that it’s not expected linked for. (It’s OK to generate positions-independent code)</p> <p><code class="language-plaintext highlighter-rouge">objdump -p </code> read the ELF file program header table, it contains the areas of ELF file need be loaded into memory, marked as <code class="language-plaintext highlighter-rouge">LOAD</code>. and another information:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Program</span> <span class="n">Header</span><span class="o">:</span>
    <span class="n">LOAD</span> <span class="n">off</span>    <span class="mh">0x000000d4</span> <span class="n">vaddr</span> <span class="mh">0x00007c00</span> <span class="n">paddr</span> <span class="mh">0x00007c00</span> <span class="n">align</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
         <span class="n">filesz</span> <span class="mh">0x00000228</span> <span class="n">memsz</span> <span class="mh">0x00000228</span> <span class="n">flags</span> <span class="n">rwx</span>

</code></pre></div></div> <hr/> <ul> <li>Ex.5: Then change the link address in boot/Makefrag to something wrong</li> </ul> <p>I know what will happen.</p> <hr/> <ul> <li>Ex.6: Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different?</li> </ul> <p>Just thinking, because loading the kernel.img ELF file into <code class="language-plaintext highlighter-rouge">0x00100000</code> physical address, so after bootloader cal kernel.ing entry point, the 8 words after <code class="language-plaintext highlighter-rouge">0x00100000</code> is full of kern.img <code class="language-plaintext highlighter-rouge">.text</code> section data.</p> <h3 id="part-iii-kernel">PART III. Kernel</h3> <h4 id="using-virtual-memory-to-work-around-position-dependence">Using virtual memory to work around position dependence</h4> <p>AS we can see above, the <code class="language-plaintext highlighter-rouge">boot.out</code> link address is equaled with load address, case its the raw physical address, but <code class="language-plaintext highlighter-rouge">kern</code> link address<code class="language-plaintext highlighter-rouge">0xf0100000</code> is different with load address<code class="language-plaintext highlighter-rouge">0x00100000</code>. <br/> Case the <code class="language-plaintext highlighter-rouge">kernel</code> always wanna linking at very high virtual address so that low address space used for user program. <br/> Up until <code class="language-plaintext highlighter-rouge">kern/entry.S</code> sets the CR0_PG flag (via writing a register), memory reference are treated as physical address. Once CR0_PG flag set, memory references are virtual address that translated by hardware to physical address.<br/> SO We need do a map about conversion of virtual address and physical address. In this lab we will map 4MB spaces.<code class="language-plaintext highlighter-rouge">entrypgdir.c</code> finished two map. 1. From kernel memory space <code class="language-plaintext highlighter-rouge">0xf0000000 - 0xf0400000</code> to physical space <code class="language-plaintext highlighter-rouge">0x00000000 - 0x00400000</code>. 2. From virtual memory space <code class="language-plaintext highlighter-rouge">0x00000000 - 0x00400000</code> to physical memory space.</p> <hr/> <ul> <li>Ex.7: What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren’t in place?</li> </ul> <p>After the instruction <code class="language-plaintext highlighter-rouge">f0100025: 0f 22 c0 mov %eax,%cr0</code>, the kernel address <code class="language-plaintext highlighter-rouge">0xf0100000</code> is mapped into physical address <code class="language-plaintext highlighter-rouge">0x00100000</code>. So the <code class="language-plaintext highlighter-rouge">x /8x ADDR</code> data result is the same.<br/> So the first instruction would failed if not mapped properly is</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">f0100028:</span>	<span class="n">b8</span> <span class="mi">2</span><span class="n">f</span> <span class="mo">00</span> <span class="mi">10</span> <span class="n">f0</span>       	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0xf010002f</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
<span class="n">f010002d</span><span class="o">:</span>	<span class="n">ff</span> <span class="n">e0</span>                	<span class="n">jmp</span>    <span class="o">*%</span><span class="n">eax</span>
</code></pre></div></div> <p>Because it using the kernel virtual address to call function. If we comment that statements:<br/> We will get error,</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mh">0xf0100026</span> <span class="o">&lt;</span><span class="n">relocated</span><span class="o">+</span><span class="mi">2</span><span class="o">&gt;:</span>    <span class="n">Error</span> <span class="k">while</span> <span class="n">running</span> <span class="n">hook_stop</span><span class="o">:</span>  
<span class="n">Cannot</span> <span class="n">access</span> <span class="n">memory</span> <span class="n">at</span> <span class="n">address</span> <span class="mh">0xf0100026</span>      
</code></pre></div></div> <h4 id="formatted-printing-to-the-console">Formatted Printing to the Console</h4> <p><code class="language-plaintext highlighter-rouge">printf.c</code> implemented basic print function formatted print function, variadic arguments printf function.<br/> <code class="language-plaintext highlighter-rouge">printfmt.c</code> implemented various formatted print functions.<br/> <code class="language-plaintext highlighter-rouge">console.c</code> implemented the terminal console and initialized some IO devices via writing the register.</p> <hr/> <ul> <li>Ex.8: We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// (unsigned) octal</span>
<span class="k">case</span> <span class="sc">'o'</span><span class="p">:</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">getuint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="p">,</span> <span class="n">lflag</span><span class="p">);</span>
  <span class="n">base</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="k">goto</span> <span class="n">number</span><span class="p">;</span>  


</code></pre></div></div> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p> </blockquote> <ul> <li>printf.c</li> </ul> <p><code class="language-plaintext highlighter-rouge">putch()</code> output a char to console, invoke the interface of <code class="language-plaintext highlighter-rouge">console.c</code>.<br/> <code class="language-plaintext highlighter-rouge">vcprintf()</code> output a formatted string and calculating the output char counts. Invoked the <code class="language-plaintext highlighter-rouge">vprintfmt()</code> of <code class="language-plaintext highlighter-rouge">printfmt.c</code>.<br/> <code class="language-plaintext highlighter-rouge">cprint()</code> the C-style like print function.</p> <ul> <li>console.c</li> </ul> <p>Mainly implement IO device initialized function such as Serial, Parallel Port, CGA/VGA Display, Keyboard. And general device independent function owned by CONSOLE. Export these interface: <code class="language-plaintext highlighter-rouge">cons_getc(void)</code>, <code class="language-plaintext highlighter-rouge">cons_init(void)</code>, <code class="language-plaintext highlighter-rouge">cputchar(int)</code>, <code class="language-plaintext highlighter-rouge">cgetchar(void)</code>, <code class="language-plaintext highlighter-rouge">iscons(void)</code>.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> Explain the following from console.c:</p> </blockquote> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">crt_pos</span> <span class="o">&gt;=</span> <span class="n">CRT_SIZE</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>              <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">3</span>              <span class="n">memmove</span><span class="p">(</span><span class="n">crt_buf</span><span class="p">,</span> <span class="n">crt_buf</span> <span class="o">+</span> <span class="n">CRT_COLS</span><span class="p">,</span> <span class="p">(</span><span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span>
<span class="mi">4</span>              <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CRT_SIZE</span> <span class="o">-</span> <span class="n">CRT_COLS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CRT_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="mi">5</span>                      <span class="n">crt_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0700</span> <span class="o">|</span> <span class="sc">' '</span><span class="p">;</span>
<span class="mi">6</span>              <span class="n">crt_pos</span> <span class="o">-=</span> <span class="n">CRT_COLS</span><span class="p">;</span>
<span class="mi">7</span>      <span class="p">}</span>
</code></pre></div></div> <p>CONSOLE using <code class="language-plaintext highlighter-rouge">crt_buf</code> and <code class="language-plaintext highlighter-rouge">crt_pos</code> to output char and recording output positions. SO if output char had filled on page screen,<br/> Clear current output buffer, and reset <code class="language-plaintext highlighter-rouge">crt_pos</code> to next new screen.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> Trace the execution of the following code step-by-step? These notes cover GCC’s calling convention on the x86.</p> </blockquote> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">cprintf</span><span class="p">(</span><span class="s">"x %d, y %x, z %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>  

</code></pre></div></div> <ul> <li>In the call to cprintf(), to what does <code class="language-plaintext highlighter-rouge">fmt</code> point? To what does <code class="language-plaintext highlighter-rouge">ap</code> point?</li> </ul> <p><code class="language-plaintext highlighter-rouge">cprintf()</code> declaration: <code class="language-plaintext highlighter-rouge">cprintf(const char *fmt, ...)</code>, so <code class="language-plaintext highlighter-rouge">fmt</code> point to <code class="language-plaintext highlighter-rouge">"x %d, y %x, z %d\n"</code> string, <code class="language-plaintext highlighter-rouge">ap</code> point to arguments list address in order.</p> <ul> <li>List (in order of execution) each call to <code class="language-plaintext highlighter-rouge">cons_putc</code>, <code class="language-plaintext highlighter-rouge">va_arg</code>, and <code class="language-plaintext highlighter-rouge">vcprintf</code>. For <code class="language-plaintext highlighter-rouge">cons_putc</code>, list its argument as well. For <code class="language-plaintext highlighter-rouge">va_arg</code>, list what <code class="language-plaintext highlighter-rouge">ap</code> points to before and after the call. For <code class="language-plaintext highlighter-rouge">vcprintf</code> list the values of its two arguments.</li> </ul> <p><code class="language-plaintext highlighter-rouge">cons_putc()</code> is in <code class="language-plaintext highlighter-rouge">console.c</code>, it defined write char to devices. <code class="language-plaintext highlighter-rouge">cons_putc()</code> is wrapped by <code class="language-plaintext highlighter-rouge">printf.c/putch()</code>, <code class="language-plaintext highlighter-rouge">putch()</code> as callback for some function in <code class="language-plaintext highlighter-rouge">printfmt.c</code>. <br/> <code class="language-plaintext highlighter-rouge">va_arg</code> used for parsing <code class="language-plaintext highlighter-rouge">va_list ap</code> pointer, mainly used in printfmt.c <code class="language-plaintext highlighter-rouge">getint()/getuint()/vprintfmt()</code> functions. <br/> <code class="language-plaintext highlighter-rouge">vcprintf()</code> defined in <code class="language-plaintext highlighter-rouge">printf.c</code>, to print specific arguments parsed in <code class="language-plaintext highlighter-rouge">cprintf()</code> function.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/* Call Stack: 
cprintf(const char* fmt, ...) 
\/
vcprintf(const char* fmt, va_list ap)
\/
void vprintfmt(void (*putch)(int, void *), void *putdat, const char *fmt, va_list ap)
\/
printnum()/putch(int ch, int *cnt)
\/
cons_putc(int ch)
*/</span>

<span class="c1">// Output: Numbers x= //</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">f</span>
<span class="cp">#2  0xf0100911 in vcprintf (fmt=0xf01019b3 "Numbers x=%d y=%d z=%d\n", 
</span>    <span class="n">ap</span><span class="o">=</span><span class="mh">0xf010afc4</span> <span class="s">"</span><span class="se">\001</span><span class="s">"</span><span class="p">)</span> <span class="n">at</span> <span class="n">kern</span><span class="o">/</span><span class="n">printf</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">21</span>
<span class="mi">21</span>              <span class="nf">vprintfmt</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">putch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">fmt</span> 
<span class="err">$</span><span class="mi">9</span> <span class="o">=</span> <span class="mh">0xf01019b3</span> <span class="s">"Numbers x=%d y=%d z=%d</span><span class="se">\n</span><span class="s">"</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">ap</span>
<span class="err">$</span><span class="mi">10</span> <span class="o">=</span> <span class="p">(</span><span class="kt">va_list</span><span class="p">)</span> <span class="mh">0xf010afc4</span> <span class="s">"</span><span class="se">\001</span><span class="s">"</span>

<span class="c1">// Output: Numbers x=1 //</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">f</span>
<span class="cp">#4  0xf01010ff in vprintfmt (putch=&lt;optimized out&gt;, putdat=0xf010af8c, 
</span>    <span class="n">fmt</span><span class="o">=</span><span class="mh">0xf01019bf</span> <span class="s">" y=%d z=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="mh">0xf010afc8</span> <span class="s">"</span><span class="se">\003</span><span class="s">"</span><span class="p">)</span> <span class="n">at</span> <span class="n">lib</span><span class="o">/</span><span class="n">printfmt</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">215</span>
<span class="mi">215</span>           <span class="nf">printnum</span><span class="p">(</span><span class="n">putch</span><span class="p">,</span> <span class="n">putdat</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">padc</span><span class="p">);</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">fmt</span> 
<span class="err">$</span><span class="mi">23</span> <span class="o">=</span> <span class="mh">0xf01019bf</span> <span class="s">" y=%d z=%d</span><span class="se">\n</span><span class="s">"</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">ap</span>
<span class="err">$</span><span class="mi">24</span> <span class="o">=</span> <span class="p">(</span><span class="kt">va_list</span><span class="p">)</span> <span class="mh">0xf010afc8</span> <span class="s">"</span><span class="se">\003</span><span class="s">"</span>

<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">f</span> 
<span class="cp">#0  cons_putc (c=c@entry=49) at kern/console.c:436
</span><span class="mi">436</span>             <span class="nf">lpt_putc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">c</span>
<span class="err">$</span><span class="mi">25</span> <span class="o">=</span> <span class="mi">49</span>

<span class="c1">// Output: Numbers x=1 y=3 //</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">f</span>
<span class="cp">#4  0xf01010ff in vprintfmt (putch=&lt;optimized out&gt;, putdat=0xf010af8c, 
</span>    <span class="n">fmt</span><span class="o">=</span><span class="mh">0xf01019c4</span> <span class="s">" z=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="mh">0xf010afcc</span> <span class="s">"</span><span class="se">\004</span><span class="s">"</span><span class="p">)</span> <span class="n">at</span> <span class="n">lib</span><span class="o">/</span><span class="n">printfmt</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">215</span>
<span class="mi">215</span>           <span class="nf">printnum</span><span class="p">(</span><span class="n">putch</span><span class="p">,</span> <span class="n">putdat</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">padc</span><span class="p">);</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">fmt</span> 
<span class="err">$</span><span class="mi">32</span> <span class="o">=</span> <span class="mh">0xf01019c4</span> <span class="s">" z=%d</span><span class="se">\n</span><span class="s">"</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">ap</span> 
<span class="err">$</span><span class="mi">33</span> <span class="o">=</span> <span class="p">(</span><span class="kt">va_list</span><span class="p">)</span> <span class="mh">0xf010afcc</span> <span class="s">"</span><span class="se">\004</span><span class="s">"</span>

<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">f</span>
<span class="cp">#0  cons_putc (c=c@entry=51) at kern/console.c:436
</span><span class="mi">436</span>             <span class="nf">lpt_putc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">c</span>
<span class="err">$</span><span class="mi">34</span> <span class="o">=</span> <span class="mi">51</span>


</code></pre></div></div> <p>As above show, x86 calling convention passing argument Rigth to Left pushed them into stack, so <code class="language-plaintext highlighter-rouge">va_list ap</code> is <code class="language-plaintext highlighter-rouge">0xf010afc4 -&gt; 0xf010afc8 -&gt; 0xf010afcc</code>, to access the arguments address. The <code class="language-plaintext highlighter-rouge">va_arg()</code> finishd the stack address changed.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise:</p> </blockquote> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x00646c72</span><span class="p">;</span>
<span class="n">cprintf</span><span class="p">(</span><span class="s">"H%x Wo%s"</span><span class="p">,</span> <span class="mi">57616</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

</code></pre></div></div> <p><strong>Output:</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Print</span> <span class="n">i</span><span class="o">:</span> <span class="n">He110</span> <span class="n">World</span>
</code></pre></div></div> <p>Because 57616(hex) = e110(decimal), <code class="language-plaintext highlighter-rouge">va_arg()</code> parsed <code class="language-plaintext highlighter-rouge">&amp;i</code> as <code class="language-plaintext highlighter-rouge">rld</code>.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen?</p> </blockquote> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cprintf</span><span class="p">(</span><span class="s">"x=%d, y=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div></div> <p>output <code class="language-plaintext highlighter-rouge">x-3, y=-2671xxx</code>, because using the statement <code class="language-plaintext highlighter-rouge">unsigned long long num = static long long getint()</code>, then <code class="language-plaintext highlighter-rouge">(long long)num</code> trigger the type overflow.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">[Q]?</code> Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p> </blockquote> <p>[TODO] HARD!!!</p> <hr/> <h5 id="challenge">Challenge</h5> <p><strong>Enhance the console to allow text to be printed in different colors. If you’re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</strong> <br/> Console printed in different colors, easy.<br/> switching VGA to graphics mode? quit. <br/> —</p> <h4 id="stack">Stack</h4> <hr/> <ul> <li>Ex.9: Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</li> </ul> <p>Before call any C function, the machine should initialized stack work done. So the stack initialized in <code class="language-plaintext highlighter-rouge">entry.S:relocated</code>. After virtual address paging.<br/> <code class="language-plaintext highlighter-rouge">entry.S:reloacted</code> clear the <code class="language-plaintext highlighter-rouge">EBP</code> register, and Using GDB can see that <code class="language-plaintext highlighter-rouge">ESP</code> start from <code class="language-plaintext highlighter-rouge">0xf010b00</code>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Section</span> <span class="n">Headers</span><span class="o">:</span>
  <span class="p">[</span><span class="n">Nr</span><span class="p">]</span> <span class="n">Name</span>              <span class="n">Type</span>            <span class="n">Addr</span>     <span class="n">Off</span>    <span class="n">Size</span>   
  <span class="p">[</span> <span class="mi">0</span><span class="p">]</span>                   <span class="nb">NULL</span>            <span class="mo">00000000</span> <span class="mo">000000</span> <span class="mo">000000</span> 
  <span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="p">.</span><span class="n">text</span>             <span class="n">PROGBITS</span>        <span class="n">f0100000</span> <span class="mo">001000</span> <span class="mo">001</span><span class="mi">94</span><span class="n">d</span> 
  <span class="p">[</span> <span class="mi">2</span><span class="p">]</span> <span class="p">.</span><span class="n">rodata</span>           <span class="n">PROGBITS</span>        <span class="n">f0101960</span> <span class="mo">002</span><span class="mi">960</span> <span class="mo">000</span><span class="mi">80</span><span class="n">c</span> 
  <span class="p">[</span> <span class="mi">3</span><span class="p">]</span> <span class="p">.</span><span class="n">note</span><span class="p">.</span><span class="n">gnu</span><span class="p">.</span><span class="n">pr</span><span class="p">[...]</span> <span class="n">NOTE</span>            <span class="n">f010216c</span> <span class="mo">00316</span><span class="n">c</span> <span class="mo">00002</span><span class="mi">8</span> 
  <span class="p">[</span> <span class="mi">4</span><span class="p">]</span> <span class="p">.</span><span class="n">stab</span>             <span class="n">PROGBITS</span>        <span class="n">f0102194</span> <span class="mo">0031</span><span class="mi">94</span> <span class="mo">000001</span> 
  <span class="p">[</span> <span class="mi">5</span><span class="p">]</span> <span class="p">.</span><span class="n">stabstr</span>          <span class="n">STRTAB</span>          <span class="n">f0102195</span> <span class="mo">0031</span><span class="mi">95</span> <span class="mo">000001</span> 
  <span class="p">[</span> <span class="mi">6</span><span class="p">]</span> <span class="p">.</span><span class="n">data</span>             <span class="n">PROGBITS</span>        <span class="n">f0103000</span> <span class="mo">004000</span> <span class="mo">00</span><span class="n">a300</span>
  <span class="p">[</span> <span class="mi">7</span><span class="p">]</span> <span class="p">.</span><span class="n">bss</span>              <span class="n">PROGBITS</span>        <span class="n">f010d300</span> <span class="mf">00e300</span> <span class="mo">000661</span> 

</code></pre></div></div> <p>And in <code class="language-plaintext highlighter-rouge">entry.S</code>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">relocated:</span>

	<span class="n">movl</span>	<span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>			<span class="err">#</span> <span class="n">nuke</span> <span class="n">frame</span> <span class="n">pointer</span>

	<span class="cp"># Set the stack pointer
</span>	<span class="n">movl</span>	<span class="err">$</span><span class="p">(</span><span class="n">bootstacktop</span><span class="p">),</span><span class="o">%</span><span class="n">esp</span>

	<span class="cp"># now to C code
</span>	<span class="n">call</span>	<span class="n">i386_init</span>

<span class="c1">// ...............</span>
	<span class="p">.</span><span class="n">p2align</span>	<span class="n">PGSHIFT</span>		<span class="err">#</span> <span class="n">force</span> <span class="n">page</span> <span class="n">alignment</span>
	<span class="p">.</span><span class="n">globl</span>		<span class="n">bootstack</span>
<span class="n">bootstack</span><span class="o">:</span>
	<span class="p">.</span><span class="n">space</span>		<span class="n">KSTKSIZE</span>
	<span class="p">.</span><span class="n">globl</span>		<span class="n">bootstacktop</span>   
<span class="n">bootstacktop</span><span class="o">:</span>

</code></pre></div></div> <p>So the stack address space layout:</p> <blockquote> <p>bootstack(0xf010300), also the <code class="language-plaintext highlighter-rouge">.data</code> section link address.<br/> bootstacktop(0xf010b00), <code class="language-plaintext highlighter-rouge">ESP</code> start to decrease.<br/> <code class="language-plaintext highlighter-rouge">.bss</code> section at (0xf010d300)</p> </blockquote> <p>The kernel link the <code class="language-plaintext highlighter-rouge">ESP</code> at high address to preserve stack address space, the space size = 0xf010b00 - 0xf010300 = 2Kib</p> <hr/> <ul> <li>Ex.10: Examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words? <br/> After first call at <code class="language-plaintext highlighter-rouge">init.c:i386_init()</code>, every time nested call will push 5 32-bit words before.<br/> First call set <code class="language-plaintext highlighter-rouge">%EAX</code> store arguments ‘five’. Then every nested call will pretend/know that <code class="language-plaintext highlighter-rouge">%EAX</code> holds this call fram function argument.<br/> Then will push <code class="language-plaintext highlighter-rouge">%EBP %EBX %EBX(After set as %EAX value) $0xf0101960 %EAX(After calculated minos 1)</code>.</li> </ul> <hr/> <ul> <li>Ex.11: mon_backtrace() function.</li> </ul> <p>OK!!</p> <ul> <li>Ex.12: Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</li> </ul> <p>[TODO]</p>]]></content><author><name></name></author><category term="system"/><summary type="html"><![CDATA[Notes about lab 1]]></summary></entry><entry><title type="html">KMP/BM String Match Algorithm</title><link href="https://jlibyvali.github.io/blog/2025/KMPBM/" rel="alternate" type="text/html" title="KMP/BM String Match Algorithm"/><published>2025-01-10T21:01:00+00:00</published><updated>2025-01-10T21:01:00+00:00</updated><id>https://jlibyvali.github.io/blog/2025/KMPBM</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2025/KMPBM/"><![CDATA[<h1 id="intro">Intro</h1> <p>花了两天时间,终于把KMP和BM算法弄懂了. 本编文章将介绍KMP和BM相关算法的实现以及过程,并引入<code class="language-plaintext highlighter-rouge">Google Benchmark</code>作初步性能测试.<br/> 本篇不追求底层理论证明,只用图表和代码阐述算法实现及思想.</p> <h2 id="tldr">TL;DR</h2> <ul> <li>性能对比图</li> </ul> <blockquote> <p><code class="language-plaintext highlighter-rouge">PATTERN</code>字符串只在<code class="language-plaintext highlighter-rouge">TEXT</code>的尾部, 中点处 出现两次, 稀疏匹配, 横坐标为搜索的<code class="language-plaintext highlighter-rouge">TEXT</code>串长度, [100,10M] 个字符, 纵坐标为<code class="language-plaintext highlighter-rouge">benchmark</code>消耗的cpu时间</p> </blockquote> <ul> <li>短序列匹配(length&lt;=5)</li> </ul> <p>pattern: ` std::string short_pattern{“abca”};`</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/short_bm.png" sizes="95vw"/> <img src="/assets/img/bm_kmp/short_bm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 短序列稀疏匹配. </div> <ul> <li>中序列匹配(5&lt;length&lt;=30)</li> </ul> <p>pattern: ` std::string medium_pattern{“HelloWWWorldHello”};`</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/medium_bm.png" sizes="95vw"/> <img src="/assets/img/bm_kmp/medium_bm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 中序列稀疏匹配. </div> <ul> <li>长序列匹配(length&gt;30)</li> </ul> <p>pattern: ` std::string long_pattern{“This isis long patternpattern string matched testThislongpatternpat”};`</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/long_bm.png" sizes="95vw"/> <img src="/assets/img/bm_kmp/long_bm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 长序列稀疏匹配. </div> <h1 id="kmp">KMP</h1> <p>先讲<code class="language-plaintext highlighter-rouge">KMP</code>算法, 先要了解概念: 字符串的<code class="language-plaintext highlighter-rouge">真前缀</code>, <code class="language-plaintext highlighter-rouge">真后缀</code>. <br/> 真前缀: 就是除了字符串<code class="language-plaintext highlighter-rouge">s</code>本身外的所有前缀, 比如串<code class="language-plaintext highlighter-rouge">abcda</code>, 则真前缀为<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">ab</code>, <code class="language-plaintext highlighter-rouge">abc</code>, <code class="language-plaintext highlighter-rouge">abcd</code>. <br/> 真后缀: 同理, 就是除了s本身外的所有后缀, 比如串<code class="language-plaintext highlighter-rouge">abcda</code>, 则真后缀为<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">da</code>, <code class="language-plaintext highlighter-rouge">cda</code>, <code class="language-plaintext highlighter-rouge">bcda</code>.</p> <h2 id="朴素算法">朴素算法</h2> <p>先来看一下朴素匹配算法: 文本串<code class="language-plaintext highlighter-rouge">TEXT = goodgoogle</code>, 模式串<code class="language-plaintext highlighter-rouge">PAT=google</code>.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">naive_match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>

    <span class="k">auto</span>             <span class="n">text_len</span> <span class="o">=</span> <span class="n">_text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">auto</span>             <span class="n">pat_len</span>  <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">matched</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pat_len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">matched</span><span class="p">)</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TEXT</span> <span class="o">=</span> <span class="s">"goodgoogle."</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">PAT</span>  <span class="o">=</span> <span class="s">"google"</span><span class="p">;</span>

    <span class="k">auto</span>        <span class="n">pos</span>  <span class="o">=</span> <span class="n">naive_match</span><span class="p">(</span><span class="n">TEXT</span><span class="p">,</span> <span class="n">PAT</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">pos</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Matched: "</span> <span class="o">&lt;&lt;</span> <span class="n">TEXT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PAT</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p>输出: Matched: google</p> </blockquote> <p>但这样无疑是非常慢的,而且重复匹配了很多可以跳过的步骤. 如图:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/1.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/1.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/2.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/2.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/3.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/3.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/4.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/4.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/5.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/5.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><code class="language-plaintext highlighter-rouge">PAT[j]</code> 的索引 j 发生了回溯, 比如<code class="language-plaintext highlighter-rouge">1 -&gt; 2</code>中, j从<code class="language-plaintext highlighter-rouge">3</code> 到了 <code class="language-plaintext highlighter-rouge">0</code>后又开始匹配, 这些回溯是可以被减少或取消的.</p> <blockquote> <p>第一次在<code class="language-plaintext highlighter-rouge">g</code> 失配后,2, 3 的匹配完全可以跳过直接到 4 .</p> </blockquote> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/1_4.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/1_4.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>所以就可以利用前缀信息, 对 <code class="language-plaintext highlighter-rouge">j</code> 的回溯进行优化,不需要每次从<code class="language-plaintext highlighter-rouge">PAT[0]</code>开始. 这样就引出了<code class="language-plaintext highlighter-rouge">next</code>数组. <br/> 我们利用的信息是在<code class="language-plaintext highlighter-rouge">PAT</code>中的<code class="language-plaintext highlighter-rouge">前缀信息</code>, 仅与<code class="language-plaintext highlighter-rouge">PAT</code>有关. 这样构建的next数组称为<code class="language-plaintext highlighter-rouge">PAT</code>的前缀函数, 对于<code class="language-plaintext highlighter-rouge">next[i]</code>的值有:</p> <ul> <li>如果子串<code class="language-plaintext highlighter-rouge">PAT[0,i]</code>前有<code class="language-plaintext highlighter-rouge">相等的</code> 真前缀和真后缀, 则 <code class="language-plaintext highlighter-rouge">next[i]</code> 的值为最长的相等真前缀真后缀的长度.</li> <li>如果没有则为<code class="language-plaintext highlighter-rouge">0</code>.</li> </ul> <p>所以<code class="language-plaintext highlighter-rouge">abcdabcd</code>的<code class="language-plaintext highlighter-rouge">next</code>数组:</p> <table> <thead> <tr> <th style="text-align: center">j</th> <th style="text-align: center">0</th> <th style="text-align: center">1</th> <th style="text-align: center">2</th> <th style="text-align: center">3</th> <th style="text-align: center">4</th> <th style="text-align: center">5</th> <th style="text-align: center">6</th> <th>7</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">PAT[j]</td> <td style="text-align: center">a</td> <td style="text-align: center">b</td> <td style="text-align: center">c</td> <td style="text-align: center">d</td> <td style="text-align: center">a</td> <td style="text-align: center">b</td> <td style="text-align: center">c</td> <td>d</td> </tr> <tr> <td style="text-align: center">next[j]</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">3</td> <td>4</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">google</code>的<code class="language-plaintext highlighter-rouge">next</code>数组:</p> <table> <thead> <tr> <th style="text-align: center">j</th> <th style="text-align: center">0</th> <th style="text-align: center">1</th> <th style="text-align: center">2</th> <th style="text-align: center">3</th> <th style="text-align: center">4</th> <th style="text-align: center">5</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">PAT[j]</td> <td style="text-align: center">g</td> <td style="text-align: center">o</td> <td style="text-align: center">o</td> <td style="text-align: center">g</td> <td style="text-align: center">l</td> <td style="text-align: center">e</td> </tr> <tr> <td style="text-align: center">next[j]</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: center">1</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">aaaaaa</code>的<code class="language-plaintext highlighter-rouge">next</code>数组:</p> <table> <thead> <tr> <th style="text-align: center">j</th> <th style="text-align: center">0</th> <th style="text-align: center">1</th> <th style="text-align: center">2</th> <th style="text-align: center">3</th> <th style="text-align: center">4</th> <th style="text-align: center">5</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">PAT[j]</td> <td style="text-align: center">a</td> <td style="text-align: center">a</td> <td style="text-align: center">a</td> <td style="text-align: center">a</td> <td style="text-align: center">a</td> <td style="text-align: center">a</td> </tr> <tr> <td style="text-align: center">next[j]</td> <td style="text-align: center">0</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">3</td> <td style="text-align: center">4</td> <td style="text-align: center">5</td> </tr> </tbody> </table> <h2 id="next数组">next数组</h2> <p>那要如何来计算<code class="language-plaintext highlighter-rouge">next</code>数组呢? 观察上述 <code class="language-plaintext highlighter-rouge">next</code>数组的变化:</p> <ul> <li><code class="language-plaintext highlighter-rouge">next[i]</code> 的值是 记录了 相等的真前缀 <code class="language-plaintext highlighter-rouge">长度</code> 和 <code class="language-plaintext highlighter-rouge">位置</code> , 我们每次只需要和<code class="language-plaintext highlighter-rouge">next[i-1]</code> 比对就可以了,不需要从头开始构造 前缀字符串 来比对.</li> <li><code class="language-plaintext highlighter-rouge">next[i]</code> 的值要么是 <code class="language-plaintext highlighter-rouge">next[i-1]</code> , 要么是 <code class="language-plaintext highlighter-rouge">next[i-1]</code> 增减 <code class="language-plaintext highlighter-rouge">1</code> .</li> </ul> <p>那就对<code class="language-plaintext highlighter-rouge">PAT</code> 从前开始遍历, 比较<code class="language-plaintext highlighter-rouge">PAT[i] == PAT[ next [ i-1 ] ] </code>, 相等则意味着 存在 更长的前缀. 不相等则回溯 <code class="language-plaintext highlighter-rouge">next[i-1]</code>. <code class="language-plaintext highlighter-rouge">next[i-1]</code> 等于0 则无需回溯.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">auto</span> <span class="n">cal_next</span> <span class="o">=</span> <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span>                      <span class="n">pat_len</span> <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">(</span><span class="n">pat_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 从 1 开始遍历, next[0] === 0</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>

        <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>那有了<code class="language-plaintext highlighter-rouge">next</code>数组后我们有两种KMP的实现:</p> <ol> <li>对朴素算法改进, 每次 <code class="language-plaintext highlighter-rouge">PAT[j]</code> 回溯时 采用<code class="language-plaintext highlighter-rouge">next[j]</code>的值, 减少匹配次数.</li> <li>构建一个字符串 <code class="language-plaintext highlighter-rouge">ALL = PAT + '#' + TEXT </code>, 因为 <code class="language-plaintext highlighter-rouge">next</code> 记录的是相等的前后缀值. 如果 <code class="language-plaintext highlighter-rouge">TEXT</code>中有<code class="language-plaintext highlighter-rouge">PAT</code>的话, 我们对<code class="language-plaintext highlighter-rouge">ALL</code> 求出的next中就会有和<code class="language-plaintext highlighter-rouge">PAT.length()</code> 相等的值. 必须用<code class="language-plaintext highlighter-rouge">#</code> 在两个字符串中均不存在的字符来分割.</li> </ol> <p>对于 <code class="language-plaintext highlighter-rouge">1.</code> 的代码:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>  


<span class="k">auto</span> <span class="nf">kmp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>

    <span class="k">auto</span>             <span class="n">next</span>     <span class="o">=</span> <span class="n">cal_next</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>

    <span class="k">auto</span>             <span class="n">text_len</span> <span class="o">=</span> <span class="n">_text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">auto</span>             <span class="n">pat_len</span>  <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>    <span class="c1">// 只要发生不匹配, 则回溯 匹配前缀长度 </span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>    <span class="c1">//记录下 已经相等的 匹配前缀长度 </span>

        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">pat_len</span><span class="p">)</span> <span class="c1">// 相等比较后, 保存 TEXT 处 PAT 的起点值. </span>
            <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">pat_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>对于 <code class="language-plaintext highlighter-rouge">2.</code> 的代码, 出自: <a href="">https://oi-wiki.org/string/kmp/#%E6%9C%80%E7%BB%88%E7%AE%97%E6%B3%95:~:text=%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82-,%E8%80%8C%E4%B8%94%E8%AF%A5%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%87%BA%E4%BA%BA%E6%84%8F%E6%96%99%E7%9A%84%E7%9F%AD%E4%B8%94%E7%9B%B4%E8%A7%82,-%EF%BC%9A</a></p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">auto</span> <span class="nf">kmp_io</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span>      <span class="n">text</span><span class="p">{</span><span class="n">_text</span><span class="p">},</span> <span class="n">pat</span><span class="p">{</span><span class="n">_pat</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span>      <span class="n">all</span>     <span class="o">=</span> <span class="n">pat</span> <span class="o">+</span> <span class="s">"#"</span> <span class="o">+</span> <span class="n">text</span><span class="p">;</span>	<span class="c1">//构造一个长字符串</span>
    <span class="k">auto</span>             <span class="n">all_len</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">auto</span>             <span class="n">pat_len</span> <span class="o">=</span> <span class="n">pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="k">auto</span>             <span class="n">next</span>    <span class="o">=</span> <span class="n">cal_next</span><span class="p">(</span><span class="n">all</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pat_len</span>  <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">all_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat_len</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pat_len</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <h1 id="boyer-moore">Boyer-Moore</h1> <blockquote> <p>KMP 适合处理<code class="language-plaintext highlighter-rouge">PAT</code>中存在许多重复序列的情况, 而且适合需要逐字符处理的实时性场景. BM相比KMP利用后缀匹配的形式获取更多的信息量和更大的<code class="language-plaintext highlighter-rouge">TEXT</code>跳转, 一般情况下 BM 性能会优于 KMP.</p> </blockquote> <blockquote> <p>对于<code class="language-plaintext highlighter-rouge">TEXT</code> 迭代量我们声明为<code class="language-plaintext highlighter-rouge">∆i</code>, <code class="language-plaintext highlighter-rouge">TEXT</code>的长度声明为<code class="language-plaintext highlighter-rouge">TEXT_len</code>, <code class="language-plaintext highlighter-rouge">PAT</code>长度声明为<code class="language-plaintext highlighter-rouge">PAT_len</code>.</p> </blockquote> <p>对于BM, 需要学习 <code class="language-plaintext highlighter-rouge">坏字符</code> 和 <code class="language-plaintext highlighter-rouge">好后缀</code> 的概念.</p> <ul> <li>坏字符, 也就是<code class="language-plaintext highlighter-rouge">TEXT</code>中失配于<code class="language-plaintext highlighter-rouge">PAT</code>处的那个字符.</li> <li>好后缀, 就是<code class="language-plaintext highlighter-rouge">TEXT</code>失配于<code class="language-plaintext highlighter-rouge">PAT</code>处的, <code class="language-plaintext highlighter-rouge">TEXT</code>和<code class="language-plaintext highlighter-rouge">PAT</code>公共相等的后缀字符串.</li> </ul> <p>如图:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/bad_good.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/bad_good.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="坏字符规则">坏字符规则</h2> <p>对于坏字符规则, 我们利用<code class="language-plaintext highlighter-rouge">坏字符表</code> 来构建 <code class="language-plaintext highlighter-rouge">TEXT</code>的迭代跳转量<code class="language-plaintext highlighter-rouge">∆i</code>. <br/> 对于<code class="language-plaintext highlighter-rouge">∆i</code> 的取值我们分为两种情况:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Bad Char</code> 在<code class="language-plaintext highlighter-rouge">PAT</code> 左侧中, 即<code class="language-plaintext highlighter-rouge">Bad Char</code> 在<code class="language-plaintext highlighter-rouge">PAT</code>失配位置之前, 取<code class="language-plaintext highlighter-rouge">PAT_len-1-p = last - p</code>, <code class="language-plaintext highlighter-rouge">p</code>为<code class="language-plaintext highlighter-rouge">Bad Char</code> 在<code class="language-plaintext highlighter-rouge">PAT</code> 中出现的最后一次 <code class="language-plaintext highlighter-rouge">索引</code>, <code class="language-plaintext highlighter-rouge">last</code> 为<code class="language-plaintext highlighter-rouge">PAT</code>的最后一个字符的<code class="language-plaintext highlighter-rouge">索引</code>:</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/badchar_p.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/badchar_p.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><strong><em>特别的</em></strong>, 当失配字符时首字符时, 一样<code class="language-plaintext highlighter-rouge">last-p</code> .</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/badchar_head.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/badchar_head.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ul> <li><code class="language-plaintext highlighter-rouge">Bad Char</code> 不在<code class="language-plaintext highlighter-rouge">PAT</code>左侧中, 直接取得<code class="language-plaintext highlighter-rouge">PAT_len</code></li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/bad_patlen.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/bad_patlen.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>一句话概括: <code class="language-plaintext highlighter-rouge">∆i = PAT最后一个字符索引 - 坏字符最后一次索引</code>, 如果<code class="language-plaintext highlighter-rouge">PAT</code> 前缀中没有坏字符取<code class="language-plaintext highlighter-rouge">pat_len</code>.</p> <h3 id="二维坏字符表">二维坏字符表</h3> <p>理解了逻辑我们就可以编写计算<code class="language-plaintext highlighter-rouge">BadChar</code>表格的代码了, 先从容易理解的二维<code class="language-plaintext highlighter-rouge">BadChar_table</code>入手.</p> <ul> <li>对于<code class="language-plaintext highlighter-rouge">TEXT</code>中可能出现的所有字符, 假设来自ASCII集合, 则令<code class="language-plaintext highlighter-rouge">行</code>为256, 对应每个字符的ASCII值.</li> <li><code class="language-plaintext highlighter-rouge">列</code>为<code class="language-plaintext highlighter-rouge">PAT</code>的每个字符.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/2D_badchar.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/2D_badchar.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>这样得到表格<code class="language-plaintext highlighter-rouge">BadChar[i][j]</code>的含义就是 <strong>在<code class="language-plaintext highlighter-rouge">PAT[j]</code>处失配了字符<code class="language-plaintext highlighter-rouge">BadChar[i]</code>时, <code class="language-plaintext highlighter-rouge">∆i</code>的取值.</strong> <br/> 取值也很有规律:</p> <ul> <li>如果<code class="language-plaintext highlighter-rouge">T[i]</code>中的badchar 有在<code class="language-plaintext highlighter-rouge">PAT</code>中出现, 则值为 <code class="language-plaintext highlighter-rouge">pat_len - 1 = last - 出现索引</code>.</li> <li>如果没有出现,则复制前一列的值.</li> </ul> <p>接下来考虑如何编码, 对于坏字符表而言. 可以先给每个<code class="language-plaintext highlighter-rouge">BadChar_table[i][j]</code>赋值为<code class="language-plaintext highlighter-rouge">PAT_len</code>, 因为<code class="language-plaintext highlighter-rouge">PAT</code>如果没有坏字符的时, <code class="language-plaintext highlighter-rouge">∆i</code>就是为<code class="language-plaintext highlighter-rouge">PAT_len</code>. 然后对<code class="language-plaintext highlighter-rouge">PAT</code>迭代, 不断更新<code class="language-plaintext highlighter-rouge">PAT</code>中每个字符的值.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">BadChar_2D</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>                           <span class="n">pat_len</span> <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    
    <span class="c1">// 二维坏字符表, 默认赋值为`pat_len`. </span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">badchar_table</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pat_len</span><span class="p">,</span> <span class="n">pat_len</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pat_len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// Begin from Second char.</span>
        <span class="p">{</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">badchar_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">badchar_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">badchar_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">badchar_table</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <h3 id="一维坏字符表">一维坏字符表</h3> <p>为了节约空间, 于是有了一维坏字符表. 一维字符表就是二维字符表只取得最后一列.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/1D_badchar.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/1D_badchar.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><code class="language-plaintext highlighter-rouge">Table[i]</code>的值含义为 失配字符<code class="language-plaintext highlighter-rouge">i</code> 到最后一个字符的间隔距离. 当然排除最后一个字符<code class="language-plaintext highlighter-rouge">pat_len - 1 </code>, 也就是 <code class="language-plaintext highlighter-rouge">i &lt; pat_len - 1</code>. 因为最后一个字符不会成为 <code class="language-plaintext highlighter-rouge">坏字符跳转的部分</code>, 不相等直接下一次循环了.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">BadChar_1D</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span>        <span class="n">pat_len</span> <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">badchar_table</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">pat_len</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">badchar_table</span><span class="p">[</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">badchar_table</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>我感觉一维坏字符表其实更好理解和编码.<br/> 一般更多的是使用一维字符表, 不过一维字符表会出现<code class="language-plaintext highlighter-rouge">无限循环</code> 的问题, 原因在于一维字符表提供<code class="language-plaintext highlighter-rouge">TEXT</code>的<code class="language-plaintext highlighter-rouge">∆i</code>太小, 从而引起匹配回溯.<br/> 比如前面表格的:</p> <table> <thead> <tr> <th style="text-align: center">j</th> <th style="text-align: center">0</th> <th style="text-align: center">1</th> <th style="text-align: center">2</th> <th style="text-align: center">3</th> <th style="text-align: center">4</th> <th style="text-align: center">……</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">char[j]</td> <td style="text-align: center">A</td> <td style="text-align: center">B</td> <td style="text-align: center">C</td> <td style="text-align: center">D</td> <td style="text-align: center">E</td> <td style="text-align: center">……</td> </tr> <tr> <td style="text-align: center">badchar[j]</td> <td style="text-align: center">2</td> <td style="text-align: center">5</td> <td style="text-align: center">1</td> <td style="text-align: center">len</td> <td style="text-align: center">len</td> <td style="text-align: center">lenA</td> </tr> </tbody> </table> <p>那在使用<code class="language-plaintext highlighter-rouge">坏字符表</code>的值迭代<code class="language-plaintext highlighter-rouge">TEXT</code>时:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/backtraking.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/backtraking.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>发现<code class="language-plaintext highlighter-rouge">PAT</code> 相比上一次发生了回退.<br/> 最后要保证, <code class="language-plaintext highlighter-rouge">∆i &gt;= Pat_len - j</code>, 即<code class="language-plaintext highlighter-rouge">∆i</code>的最小值是<code class="language-plaintext highlighter-rouge">Pat_len - PAT的失配位置</code>,最小值为1. 所以如果只使用<code class="language-plaintext highlighter-rouge">一维坏字符表</code> 则跳转量代码:<br/> ` i += std::max(badchar_table[_text[i] ], pat_len - j ) `</p> <h2 id="好后缀规则">好后缀规则</h2> <p>我们利用好后缀可以获得比坏字符更大的<code class="language-plaintext highlighter-rouge">TEXT</code>跳转量. 一般好后缀的存在分为两种情况:</p> <ol> <li>好后缀部分匹配或不存在, 即好后缀的一部分在<code class="language-plaintext highlighter-rouge">PAT</code>中出现或者完全没有, 这时<code class="language-plaintext highlighter-rouge">∆i</code>的取值相比<code class="language-plaintext highlighter-rouge">2.</code>会更大.</li> <li>好后缀完整地出现在<code class="language-plaintext highlighter-rouge">PAT</code>中.</li> </ol> <p>所以为了不错过匹配位置, 我们先处理<code class="language-plaintext highlighter-rouge">1.</code>, 然后对同一个<code class="language-plaintext highlighter-rouge">GoodSuffix_table</code>处理<code class="language-plaintext highlighter-rouge">2</code>. 这样就得到了最终的<code class="language-plaintext highlighter-rouge">GoodSuffix_table</code> 表格.</p> <h3 id="好后缀部分匹配或不存在">好后缀部分匹配或不存在</h3> <p>首先不存在很简单, <code class="language-plaintext highlighter-rouge">∆i = pat_len + suffix_len</code>:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/none_matched.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/none_matched.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>对于部分匹配的情况, <code class="language-plaintext highlighter-rouge">∆i</code>的取值为上述提到不匹配的值减去<code class="language-plaintext highlighter-rouge">matched_len</code>.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/part_matched.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/part_matched.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <blockquote> <p>那现在看来, 问题在如何求 <code class="language-plaintext highlighter-rouge">matched_len</code>?</p> </blockquote> <p>可以观察下<code class="language-plaintext highlighter-rouge">matched_len</code>的变化:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/matched_len.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/matched_len.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>可以发现对于<code class="language-plaintext highlighter-rouge">matched_len</code>, 如果有新的<code class="language-plaintext highlighter-rouge">完全相等</code>的前后缀, 则更新为<code class="language-plaintext highlighter-rouge">prefix_len</code>的长度, 如果没有则保持前一个<code class="language-plaintext highlighter-rouge">matched_len</code>不变. 这里也有点像KMP的<code class="language-plaintext highlighter-rouge">next</code>数组的求值:</p> <blockquote> <p>如果 PAT[j] 前有相等的真前缀 真后缀. 则取值为它们的长度. 如果没有且<code class="language-plaintext highlighter-rouge">j</code>大与0, 则回溯比较, <code class="language-plaintext highlighter-rouge">j</code> 为 0 则直接赋值给<code class="language-plaintext highlighter-rouge">next</code>就好了</p> </blockquote> <p>所以最后<code class="language-plaintext highlighter-rouge">∆i = pat_len + suffix_len - matched_len</code>, 对于 <code class="language-plaintext highlighter-rouge">1.</code> 而言, <code class="language-plaintext highlighter-rouge">matched_len = 0</code>. 所以最后得到<code class="language-plaintext highlighter-rouge">∆i</code>的 变化公式:</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">∆i = pat_len + 好后缀长度 - 匹配部分的长度</code>, 无匹配部分则matched_len = 0.</p> </blockquote> <p>那如何计算<code class="language-plaintext highlighter-rouge">GoodSuffix_table</code>, 我们声明一个长度为<code class="language-plaintext highlighter-rouge">pat_len</code>的表格, 默认初始值为1. 然后从后开始遍历<code class="language-plaintext highlighter-rouge">PAT</code>, 不断取得前缀 和 后缀字符串作比较. 相等则更新<code class="language-plaintext highlighter-rouge">matched_len</code>的值, 不等则沿用上一次<code class="language-plaintext highlighter-rouge">last_matched_len</code>的值. 两个值初始均为 0 .</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">const</span> <span class="kt">int</span>        <span class="n">pat_len</span> <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">good_table</span><span class="p">(</span><span class="n">pat_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">int</span>              <span class="n">last_matched_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span>  <span class="n">matched_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span>  <span class="n">bad_idx</span>     <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">suffix</span>      <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">prefix</span>      <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">suffix</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">matched_len</span>      <span class="o">=</span> <span class="n">prefix</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
            <span class="n">last_matched_len</span> <span class="o">=</span> <span class="n">matched_len</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">matched_len</span> <span class="o">=</span> <span class="n">last_matched_len</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">good_table</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">matched_len</span><span class="p">;</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>这样看下来<code class="language-plaintext highlighter-rouge">good_table[i]</code>的值的确会偏大, 这样有可能错过匹配位置导致出错, 所以我们需要计算 <code class="language-plaintext highlighter-rouge">2.</code> 的情况了.</p> <h3 id="好后缀完全匹配">好后缀完全匹配</h3> <p>一个<code class="language-plaintext highlighter-rouge">好后缀</code>完全匹配在<code class="language-plaintext highlighter-rouge">PAT</code>前缀中, 那这个<code class="language-plaintext highlighter-rouge">好后缀</code> 有可能在开头, 有可能在中间, 也有可能紧挨着失配位置. 那如何区分并取得在<code class="language-plaintext highlighter-rouge">PAT</code>中最右的位置呢?</p> <p>这里就要使用<code class="language-plaintext highlighter-rouge">Longest Common Suffix</code>, 最长公共后缀了, 我们每次取<code class="language-plaintext highlighter-rouge">前缀子串</code> 和<code class="language-plaintext highlighter-rouge">PAT</code> 一起求LCS的值, 然后取最长前缀. 那就是我们要找的, 最靠右的<code class="language-plaintext highlighter-rouge">完全匹配好后缀</code>:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/LCS.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/LCS.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">auto</span> <span class="n">cal_LCS_len</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span>   <span class="n">str1_len</span> <span class="o">=</span> <span class="n">str1</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">auto</span>   <span class="n">str2_len</span> <span class="o">=</span> <span class="n">str2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

        <span class="k">auto</span>   <span class="n">mini_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">str1_len</span><span class="p">,</span> <span class="n">str2_len</span><span class="p">);</span>

        <span class="kt">size_t</span> <span class="n">i</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mini_len</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span><span class="p">[</span><span class="n">str1_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str2</span><span class="p">[</span><span class="n">str2_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>现在有了计算出的LCS, 来计算<code class="language-plaintext highlighter-rouge">∆i</code>的值, 对于<code class="language-plaintext highlighter-rouge">∆i</code> 首先看下完全匹配是如何跳转的:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/cal_be.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/cal_be.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><code class="language-plaintext highlighter-rouge">∆i</code>的值需要取得<code class="language-plaintext highlighter-rouge">好后缀</code>在<code class="language-plaintext highlighter-rouge">PAT</code>中起点位置, 而我们是从前往后构建的<code class="language-plaintext highlighter-rouge">前缀</code>子串, 所以可以利用计算的<code class="language-plaintext highlighter-rouge">LCS</code>的公共长度来求<code class="language-plaintext highlighter-rouge">be</code>.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bm_kmp/be.jpeg" sizes="95vw"/> <img src="/assets/img/bm_kmp/be.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre> <span class="c1">// i: the prefix last char's index.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prefix</span>  <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">LCS_len</span> <span class="o">=</span> <span class="n">cal_LCS_len</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_pat</span><span class="p">);</span>
        <span class="kt">int</span>  <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">LCS_len</span><span class="p">;</span>	<span class="c1">//失配位置. </span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LCS_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// 只有LCS的长度大于0才有意义. </span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">prefix_head</span>     <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">LCS_len</span><span class="p">;</span>
            <span class="n">good_table</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">prefix_head</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>这样我们就求的了在<code class="language-plaintext highlighter-rouge">PAT</code>中<code class="language-plaintext highlighter-rouge">完全匹配好后缀</code>时的<code class="language-plaintext highlighter-rouge">TEXT</code>串跳转量.<br/> 最后综合以上所有代码就可以得到,利用<code class="language-plaintext highlighter-rouge">坏字符</code>和<code class="language-plaintext highlighter-rouge">好后缀</code>规则的BM算法:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">BadChar_1D</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span>        <span class="n">pat_len</span> <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">badchar_table</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">pat_len</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">badchar_table</span><span class="p">[</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">badchar_table</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">GoodSuffix</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// res table</span>
    <span class="k">const</span> <span class="kt">int</span>        <span class="n">pat_len</span> <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">good_table</span><span class="p">(</span><span class="n">pat_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// First issue, calculate the situation that suffix is NOT complete matched in string, i.e., The suffix is partly</span>
    <span class="c1">// matched or not at all.</span>
    <span class="c1">// This kind situation table's value will bigger, we NEED don't loose ANY Potential match.</span>

    <span class="kt">int</span>              <span class="n">last_matched_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span>  <span class="n">matched_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span>  <span class="n">bad_idx</span>     <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">suffix</span>      <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">prefix</span>      <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">suffix</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">matched_len</span>      <span class="o">=</span> <span class="n">prefix</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
            <span class="n">last_matched_len</span> <span class="o">=</span> <span class="n">matched_len</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">matched_len</span> <span class="o">=</span> <span class="n">last_matched_len</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">good_table</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">matched_len</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Second Issue, the suffix is completely matched in pattern string, the `step size` is smaller, so calculate in the</span>
    <span class="c1">// last. So that we will not jump over the matched part.</span>

    <span class="k">auto</span> <span class="n">cal_LCS_len</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span>   <span class="n">str1_len</span> <span class="o">=</span> <span class="n">str1</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">auto</span>   <span class="n">str2_len</span> <span class="o">=</span> <span class="n">str2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

        <span class="k">auto</span>   <span class="n">mini_len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">str1_len</span><span class="p">,</span> <span class="n">str2_len</span><span class="p">);</span>

        <span class="kt">size_t</span> <span class="n">i</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mini_len</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span><span class="p">[</span><span class="n">str1_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str2</span><span class="p">[</span><span class="n">str2_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">// i: the prefix last index.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">prefix</span>  <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">LCS_len</span> <span class="o">=</span> <span class="n">cal_LCS_len</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_pat</span><span class="p">);</span>
        <span class="kt">int</span>  <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">LCS_len</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LCS_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">prefix_head</span>     <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">LCS_len</span><span class="p">;</span>
            <span class="n">good_table</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">prefix_head</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">good_table</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bm</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_text</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">int</span>        <span class="n">pat_len</span>          <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span>        <span class="n">text_len</span>         <span class="o">=</span> <span class="n">_text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="k">const</span> <span class="k">auto</span>       <span class="n">badchar_table</span>    <span class="o">=</span> <span class="n">BadChar_1D</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span>       <span class="n">goodsuffix_table</span> <span class="o">=</span> <span class="n">GoodSuffix</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>

    <span class="c1">// From End traverse to calculate the match.</span>
    <span class="kt">int</span>              <span class="n">i</span>                <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">text_len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">pat_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">badchar_table</span><span class="p">[</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">goodsuffix_table</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="c1">// 注意从`坏字符表` 和 `好后缀表` 里选择最大的跳转量.  </span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <h1 id="bm-horspool">BM-Horspool</h1> <p>我们利用一维<code class="language-plaintext highlighter-rouge">坏字符</code>表就可以写出 <code class="language-plaintext highlighter-rouge">BM-Horspool</code> 算法了. <code class="language-plaintext highlighter-rouge">BM-Horspool</code>实现简单而且也有不错的性能.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bm_horspool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_text</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span>              <span class="n">pat_len</span>       <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">long</span>             <span class="n">text_len</span>      <span class="o">=</span> <span class="n">_text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="k">auto</span>             <span class="n">badchar_table</span> <span class="o">=</span> <span class="n">BadChar_1D</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>

    <span class="kt">int</span>              <span class="n">i</span>             <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">text_len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">_pat</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>  
            <span class="o">--</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">badchar_table</span><span class="p">[</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 注意选择最大跳转量, 而 `pat_len - j &gt;= 1`</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <h1 id="bmhbnfs">BMHBNFS</h1> <p>最后介绍一个最快版本的BMHBNFS也叫BM5S算法, 它具体利用了<code class="language-plaintext highlighter-rouge">坏字符表</code>和<code class="language-plaintext highlighter-rouge">快速位判断表</code>的概念:</p> <ul> <li>坏字符表, 依旧是前面提到的一维坏字符表.</li> <li>快速位判断表, 因为一个<code class="language-plaintext highlighter-rouge">char</code>占1字节, 256bits. 所以每个字符都会有不同的位序列, 通过位运算来记录<code class="language-plaintext highlighter-rouge">PAT</code>字符信息, 并用作比较.</li> </ul> <p>计算这两个表的代码:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">auto</span> <span class="n">cal_skip_tables</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
    <span class="p">{</span>
    
        <span class="k">struct</span> <span class="nc">skip_fast</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="kt">int</span>                <span class="n">pat_len</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>         <span class="n">skip</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span><span class="o">&gt;</span> <span class="n">fast</span><span class="p">;</span>  <span class="c1">// Record pattern string's every char position with a bit value.</span>

            <span class="k">explicit</span> <span class="n">skip_fast</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span> <span class="o">:</span> <span class="n">pat_len</span><span class="p">(</span><span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">()),</span> <span class="n">skip</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">pat_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">fast</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">skip</span><span class="p">[</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>  <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 依旧是一维坏字符表</span>
                    <span class="n">fast</span><span class="p">[</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// 位运算 记录 `PAT` 中每个字符的 位序列  </span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="o">~</span><span class="n">skip_fast</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">skip_fast</span> <span class="nf">tables</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">tables</span><span class="p">;</span>
    <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>算法实现:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bm_5s</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_text</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">pos</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">pat_len</span>         <span class="o">=</span> <span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">text_len</span>        <span class="o">=</span> <span class="n">_text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="k">auto</span> <span class="n">cal_skip_tables</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">skip_fast</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="kt">int</span>                <span class="n">pat_len</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>         <span class="n">skip</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span><span class="o">&gt;</span> <span class="n">fast</span><span class="p">;</span>  <span class="c1">// Record pattern string's every char position with a bit value.</span>

            <span class="k">explicit</span> <span class="n">skip_fast</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">_pat</span><span class="p">)</span> <span class="o">:</span> <span class="n">pat_len</span><span class="p">(</span><span class="n">_pat</span><span class="p">.</span><span class="n">length</span><span class="p">()),</span> <span class="n">skip</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">pat_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">fast</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pat_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">skip</span><span class="p">[</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>  <span class="o">=</span> <span class="n">pat_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
                    <span class="n">fast</span><span class="p">[</span><span class="n">_pat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="o">~</span><span class="n">skip_fast</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">skip_fast</span> <span class="nf">tables</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">tables</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="n">skip_tables</span> <span class="o">=</span> <span class="n">cal_skip_tables</span><span class="p">(</span><span class="n">_pat</span><span class="p">);</span>

    <span class="kt">int</span>  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">text_len</span> <span class="o">-</span> <span class="n">pat_len</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="c1">// 比较 `TEXT`字符和 `PAT` 首字符是否相等.  </span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skip_tables</span><span class="p">.</span><span class="n">fast</span><span class="p">[</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))))</span>
        <span class="p">{</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">skip_tables</span><span class="p">.</span><span class="n">skip</span><span class="p">[</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">pat_len</span><span class="p">]];</span> <span class="c1">//如果不相等, 则跳转</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 如果前面首字符相等, 则进行后续匹配.  </span>
        <span class="kt">bool</span> <span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pat_len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skip_tables</span><span class="p">.</span><span class="n">fast</span><span class="p">[</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))))</span>
            <span class="p">{</span>
                <span class="n">match</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 最后检查</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">)</span>
                <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="n">skip_tables</span><span class="p">.</span><span class="n">skip</span><span class="p">[</span><span class="n">_text</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">pat_len</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <h1 id="ref">Ref</h1> <p><a href="">https://oi-wiki.org/string/</a> <a href="">https://writings.sh/post/algorithm-string-searching-boyer-moore</a> <a href="">https://writings.sh/post/algorithm-string-searching-kmp</a> <a href="">https://zh.z-lib.fm/book/16707410/2119d8/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</a></p>]]></content><author><name></name></author><category term="code"/><category term="algorithm"/><summary type="html"><![CDATA[Recording the algorithm implementation]]></summary></entry><entry><title type="html">Linux resources manage tools</title><link href="https://jlibyvali.github.io/blog/2024/linux-sources/" rel="alternate" type="text/html" title="Linux resources manage tools"/><published>2024-07-18T19:53:00+00:00</published><updated>2024-07-18T19:53:00+00:00</updated><id>https://jlibyvali.github.io/blog/2024/linux-sources</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2024/linux-sources/"><![CDATA[<p>首先我们了解一下系统中需要查询的基本资源信息，比如查看系统的<code class="language-plaintext highlighter-rouge">硬件资源状态</code>,<code class="language-plaintext highlighter-rouge">进程状态</code>,<code class="language-plaintext highlighter-rouge">内存使用</code>,<code class="language-plaintext highlighter-rouge">cpu使用</code>,<code class="language-plaintext highlighter-rouge">服务状态</code>,<code class="language-plaintext highlighter-rouge">端口状态</code>。<br/> 常用工具一般有实时的和非实时的。在紧密监视系统进程变化时，实时的工具对我们非常有用。 此文主要结合opensuse文档和自己的使用经验。</p> <h1 id="multi-purpose-tools">Multi-purpose tools</h1> <h2 id="vmstat">vmstat</h2> <p>vmstat 是一个可以展示有关进程，内存，分页，块设备IO,陷阱，磁盘和cpu活动的综合性工具。在Fedora中位于coreutil软件包中，在Debian/Ubuntu中位于sysstat软件包内。输出如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st gu
 1  1      0 8229040   5500 4186244    0    0    26    53  234    2  1  1 98  0  0  0
</code></pre></div></div> <p>输出内容从左到有分别是<code class="language-plaintext highlighter-rouge">正在运行的进程状态</code>,<code class="language-plaintext highlighter-rouge">内存使用状态</code>,<code class="language-plaintext highlighter-rouge">内存交换空间</code>,<code class="language-plaintext highlighter-rouge">快设备IO</code>,<code class="language-plaintext highlighter-rouge">系统中断状态</code>,<code class="language-plaintext highlighter-rouge">cpu消耗</code>状态。 cli内直接输入<code class="language-plaintext highlighter-rouge">vmstat</code>输出的信息是自启动以来的平均值,可以衔接<code class="language-plaintext highlighter-rouge">[delay [count] ]</code>参数间隔时间采集信息。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ vmstat 1 
procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st gu
 2  1      0 8489208   5500 4149584    0    0    26    57  265    3  2  1 98  0  0  0
 0  0      0 8518180   5500 4125708    0    0     0  4704 2868 1620  0  1 98  1  0  0
 0  0      0 8541876   5500 4116808    0    0     0   608 1442 1017  0  0 99  1  0  0
 2  0      0 8536144   5500 4113104    0    0     0     0  324  387  0  0 100  0  0  0
 0  0      0 8539732   5500 4112700    0    0     0     0  474  581  0  0 99  0  0  0
^C
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Usage:
 vmstat [options] [delay [count]]

Options:
 -a, --active           active/inactive memory
 -f, --forks            number of forks since boot
 -m, --slabs            slabinfo
 -n, --one-header       do not redisplay header
 -s, --stats            event counter statistics
 -d, --disk             disk statistics
 -D, --disk-sum         summarize disk statistics
 -p, --partition &lt;dev&gt;  partition specific statistics
 -S, --unit &lt;char&gt;      define display unit
 -w, --wide             wide output
 -t, --timestamp        show timestamp
 -y, --no-first         skips first line of output

 -h, --help     display this help and exit
 -V, --version  output version information and exit
</code></pre></div></div> <blockquote> <p>第一行输出永远是重启来的平均值</p> </blockquote> <h2 id="dstat">dstat</h2> <p>专业的实时工具,你可以用它来实时分析磁盘吞吐和网络吞吐量。默认采集间隔1s。 Fedora系统在`pcp-system-tools</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ dstat --help 
Usage: dstat [-afv] [options...] [delay [count]]
Versatile tool for generating system resource statistics

Dstat options:
  -c, --cpu             enable cpu stats
     -C 0,3,total          include cpu0, cpu3 and total
  -d, --disk            enable disk stats
     -D total,sda          include sda and total
  --dm, --device-mapper enable device mapper stats
     -L root,home,total    include root, home and total
  --md, --multi-device  enable multi-device driver stats
     -M total,md-0         include md-0 and total
  --part, --partition   enable disk partition stats
     -P total,sdb2         include sdb2 and total
  -g, --page            enable page stats
  -i, --int             enable interrupt stats
     -I 9,CAL              include int9 and function call interrupts
  -l, --load            enable load stats
  -m, --mem             enable memory stats
  -n, --net             enable network stats
     -N eth1,total         include eth1 and total
  -p, --proc            enable process stats
  -r, --io              enable io stats (I/O requests completed)
  -s, --swap            enable swap stats
     -S swap1,total        include swap1 and total
  -t, --time            enable time/date output
  --time-adv            enable time/date output (with milliseconds)
  -T, --epoch           enable time counter (seconds since epoch)
  --epoch-adv           enable time counter (milliseconds since epoch)
  -y, --sys             enable system stats

  --aio                 enable aio stats
  --fs, --filesystem    enable fs stats
  --ipc                 enable ipcstats
  --lock                enable lockstats
  --raw                 enable rawstats
  --socket              enable socketstats
  --tcp                 enable tcpstats
  --udp                 enable udpstats
  --unix                enable unixstats
  --vm                  enable vmstats
  --vm-adv              enable advanced vm stats

  --list                list all available plugins
  --plugin              enable external plugin by name, see --list

  -a, --all             equals -cdngy (default)
  -f, --full            automatically expand -C, -D, -I, -N and -S lists
  -v, --vmstat          equals -pmgdsc -D total

  --bits                force bits for values expressed in bytes
  --float               force float values on screen
  --integer             force integer values on screen

  --bw, --blackonwhite  change colors for white background terminal
  --color               force colors
  --nocolor             disable colors
  --noheaders           disable repetitive headers
  --noupdate            disable intermediate updates
  --nomissed            disable missed ticks warnings
  -o file, --output=file
                        write CSV output to file

delay is the delay in seconds between each update (default: 1)
count is the number of updates to display before exiting (default: unlimited)
</code></pre></div></div> <p>输出内容：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ dstat
You did not select any stats, using -cdngy by default.
----total-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw 
  0   0 100   0   0|   0   100k| 271B  282B|   0     0 | 583   699 
  0   0  99   0   0|   0   104k|   0     0 |   0     0 | 480   540 
  0   0 100   0   0|   0     0 |  66B   94B|   0     0 | 415   482 
  0   0  99   0   0|   0  4096B|   0     0 |   0     0 | 350   406 
  0   0 100   0   0|   0     0 |   0     0 |   0     0 | 338   388 ^C
</code></pre></div></div> <p>也可以输出csv格式的文件。</p> <h2 id="sar">sar</h2> <p>sar也是一个实时工具，能输出更为全面详细的信息，sar从/proc文件系统中收集信息，输出日志文件在/var/log/saDD中(DD是系统的日期)。使用sar时需要先配置并启用sysstat服务。sar也是sysstat软件包的一部分。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ sar --help
Usage: sar [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]
Main options and reports (report name between square brackets):
	-B	Paging statistics [A_PAGE]
	-b	I/O and transfer rate statistics [A_IO]
	-d	Block devices statistics [A_DISK]
	-F [ MOUNT ]
		Filesystems statistics [A_FS]
	-H	Hugepages utilization statistics [A_HUGE]
	-I [ SUM | ALL ]
		Interrupts statistics [A_IRQ]
	-m { &lt;keyword&gt; [,...] | ALL }
		Power management statistics [A_PWR_...]
		Keywords are:
		BAT	Batteries capacity
		CPU	CPU instantaneous clock frequency
		FAN	Fans speed
		FREQ	CPU average clock frequency
		IN	Voltage inputs
		TEMP	Devices temperature
		USB	USB devices plugged into the system
	-n { &lt;keyword&gt; [,...] | ALL }
		Network statistics [A_NET_...]
		Keywords are:
		DEV	Network interfaces
		EDEV	Network interfaces (errors)
		NFS	NFS client
		NFSD	NFS server
		SOCK	Sockets	(v4)
		IP	IP traffic	(v4)
		EIP	IP traffic	(v4) (errors)
		ICMP	ICMP traffic	(v4)
		EICMP	ICMP traffic	(v4) (errors)
		TCP	TCP traffic	(v4)
		ETCP	TCP traffic	(v4) (errors)
		UDP	UDP traffic	(v4)
		SOCK6	Sockets	(v6)
		IP6	IP traffic	(v6)
		EIP6	IP traffic	(v6) (errors)
		ICMP6	ICMP traffic	(v6)
		EICMP6	ICMP traffic	(v6) (errors)
		UDP6	UDP traffic	(v6)
		FC	Fibre channel HBAs
		SOFT	Software-based network processing
	-q [ &lt;keyword&gt; [,...] | PSI | ALL ]
		System load and pressure-stall statistics
		Keywords are:
		LOAD	Queue length and load average statistics [A_QUEUE]
		CPU	Pressure-stall CPU statistics [A_PSI_CPU]
		IO	Pressure-stall I/O statistics [A_PSI_IO]
		MEM	Pressure-stall memory statistics [A_PSI_MEM]
	-r [ ALL ]
		Memory utilization statistics [A_MEMORY]
	-S	Swap space utilization statistics [A_MEMORY]
	-u [ ALL ]
		CPU utilization statistics [A_CPU]
	-v	Kernel tables statistics [A_KTABLES]
	-W	Swapping statistics [A_SWAP]
	-w	Task creation and system switching statistics [A_PCSW]
	-y	TTY devices statistics [A_SERIAL]
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">sar 2 10</code>就是2s内采样10次，<code class="language-plaintext highlighter-rouge">sar 1 10 -P ALL</code>可以每秒采样10次ALL个cpu核心的使用状态：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ➜  ~ sar 1 10 -P ALL  
Linux 6.10.4-200.fc40.x86_64 (bogon) 	08/18/2024 	_x86_64_	(8 CPU)

05:27:40 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
05:27:41 PM     all      0.12      0.00      0.12      0.38      0.00     99.38
05:27:41 PM       0      1.00      0.00      0.00      0.00      0.00     99.00
05:27:41 PM       1      0.00      0.00      0.00      2.00      0.00     98.00
05:27:41 PM       2      0.00      0.00      0.00      1.00      0.00     99.00
05:27:41 PM       3      0.00      0.00      0.00      0.00      0.00    100.00
05:27:41 PM       4      0.00      0.00      0.00      0.00      0.00    100.00
05:27:41 PM       5      0.00      0.00      0.00      0.00      0.00    100.00
05:27:41 PM       6      0.00      0.00      0.00      0.00      0.00    100.00
05:27:41 PM       7      0.00      0.00      1.00      0.00      0.00     99.00
^C

Average:        CPU     %user     %nice   %system   %iowait    %steal     %idle
Average:        all      0.12      0.00      0.12      0.38      0.00     99.38
Average:          0      1.00      0.00      0.00      0.00      0.00     99.00
Average:          1      0.00      0.00      0.00      2.00      0.00     98.00
Average:          2      0.00      0.00      0.00      1.00      0.00     99.00
Average:          3      0.00      0.00      0.00      0.00      0.00    100.00
Average:          4      0.00      0.00      0.00      0.00      0.00    100.00
Average:          5      0.00      0.00      0.00      0.00      0.00    100.00
Average:          6      0.00      0.00      0.00      0.00      0.00    100.00
Average:          7      0.00      0.00      1.00      0.00      0.00     99.00

</code></pre></div></div> <p>最后会统计出平均值, 比如<code class="language-plaintext highlighter-rouge">%iowait</code>,显示了cpu等待IO请求的空闲时间，如果这个值长期高于0,则说明磁盘或者网络存在瓶颈。<code class="language-plaintext highlighter-rouge">%idle</code>则说明了cpu空闲状态，如果长期为0，则说明cpu在满负荷运载。（我觉得htop更直观）。 <br/> 然后是内存可以用<code class="language-plaintext highlighter-rouge">sar -r </code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ sar -r 1 10 
Linux 6.10.4-200.fc40.x86_64 (bogon) 	08/18/2024 	_x86_64_	(8 CPU)

05:39:46 PM kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
05:39:47 PM   7964424  11464048   3740680     23.03      5500   4188456  19655328     79.80   5100952   2184304      1388
05:39:48 PM   7965356  11464980   3735900     23.00      5500   4192304  19659424     79.81   5100768   2184304      1404
05:39:49 PM   7985484  11485112   3732856     22.98      5500   4175200  19642320     79.74   5100608   2184308       776
^C
Average:      7971755  11471380   3736479     23.00      5500   4185320  19652357     79.78   5100776   2184305      1189
</code></pre></div></div> <p>然后是分页情况可以用<code class="language-plaintext highlighter-rouge">sar -B</code>,</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ sar 3 5 -B 
Linux 6.10.4-200.fc40.x86_64 (bogon) 	08/18/2024 	_x86_64_	(8 CPU)

05:41:03 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s  pgprom/s   pgdem/s
05:41:06 PM      0.00    233.33    404.33      0.00   2260.33      0.00      0.00      0.00      0.00      0.00
05:41:09 PM      0.00      1.33    460.00      0.00   1507.33      0.00      0.00      0.00      0.00      0.00
^C
Average:         0.00    117.33    432.17      0.00   1883.83      0.00      0.00      0.00      0.00      0.00

</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">majft/s</code>展示了每一秒的主要页错误，这个很常见，在程序加载请求内存某处的数据时，如果无法找到该页则会向内核发送一个缺页请求，然后内核会试图在磁盘内寻找该页并复制。 同样的对于设备读取可以使用<code class="language-plaintext highlighter-rouge">sar -d </code>选项</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ sar -d 1 10 -p 
Linux 6.10.4-200.fc40.x86_64 (bogon) 	08/18/2024 	_x86_64_	(8 CPU)

05:45:35 PM       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util DEV
05:45:36 PM     26.00      0.00    280.00      0.00     10.77      0.04      1.23      2.90 nvme0n1
05:45:36 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00 zram0

05:45:36 PM       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util DEV
05:45:37 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00 nvme0n1
05:45:37 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00 zram0

05:45:37 PM       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util DEV
05:45:38 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00 nvme0n1
05:45:38 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00 zram0
^C

Average:          tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util DEV
Average:         8.67      0.00     93.33      0.00     10.77      0.01      1.23      0.97 nvme0n1
Average:         0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00 zram0

</code></pre></div></div> <p>对于网络状态监测可以查看<code class="language-plaintext highlighter-rouge">sar -n [keyword]</code>,我们可以加入对应的[keyword]来查看相应内容</p> <ul> <li>DEV: Generates a statistic report for all network devices</li> <li>EDEV: Generates an error statistics report for all network devices</li> <li>NFS: Generates a statistic report for an NFS client</li> <li>NFSD: Generates a statistic report for an NFS server</li> <li>SOCK: Generates a statistic report on sockets</li> <li>ALL: Generates all network statistic reports</li> </ul> <h2 id="top和htop">top和htop</h2> <p>top：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ top --help 

Usage:
 top [options]

Options:
 -b, --batch-mode                run in non-interactive batch mode
 -c, --cmdline-toggle            reverse last remembered 'c' state
 -d, --delay =SECS [.TENTHS]     iterative delay as SECS [.TENTHS]
 -E, --scale-summary-mem =SCALE  set mem as: k,m,g,t,p,e for SCALE
 -e, --scale-task-mem =SCALE     set mem with: k,m,g,t,p for SCALE
 -H, --threads-show              show tasks plus all their threads
 -i, --idle-toggle               reverse last remembered 'i' state
 -n, --iterations =NUMBER        exit on maximum iterations NUMBER
 -O, --list-fields               output all field names, then exit
 -o, --sort-override =FIELD      force sorting on this named FIELD
 -p, --pid =PIDLIST              monitor only the tasks in PIDLIST
 -S, --accum-time-toggle         reverse last remembered 'S' state
 -s, --secure-mode               run with secure mode restrictions
 -U, --filter-any-user =USER     show only processes owned by USER
 -u, --filter-only-euser =USER   show only processes owned by USER
 -w, --width [=COLUMNS]          change print width [,use COLUMNS]
 -1, --single-cpu-toggle         reverse last remembered '1' state

 -h, --help                      display this help text, then exit
 -V, --version                   output version information &amp; exit

</code></pre></div></div> <p>对于top输出的信息：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top - 17:57:31 up 19:35,  1 user,  load average: 0.50, 0.35, 0.32 # 系统时间，登陆用户，系统负载：最近1min，5min，15min
Tasks: 331 total,   1 running, 330 sleeping,   0 stopped,   0 zombie #进程状态
%Cpu(s):  6.4 us,  0.6 sy,  0.0 ni, 92.6 id,  0.1 wa,  0.1 hi,  0.2 si,  0.0 st  # 内存状态
MiB Mem :  15862.5 total,   7572.7 free,   4868.6 used,   4280.7 buff/cache     # 内存使用
MiB Swap:   8192.0 total,   8192.0 free,      0.0 used.  10993.9 avail Mem 		# 交换空间状态

</code></pre></div></div> <p>在top内按h可以进入help：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Help for Interactive Commands - procps-ng 4.0.4
Window 1:Def: Cumulative mode Off.  System: Delay 3.0 secs; Secure mode Off.

  Z,B,E,e   Global: 'Z' colors; 'B' bold; 'E'/'e' summary/task memory scale
  l,t,m,I,0 Toggle: 'l' load avg; 't' task/cpu; 'm' memory; 'I' Irix; '0' zeros
  1,2,3,4,5 Toggle: '1/2/3' cpu/numa views; '4' cpus abreast; '5' P/E-cores
  f,X       Fields: 'f' add/remove/order/sort; 'X' increase fixed-width fields

  L,&amp;,&lt;,&gt; . Locate: 'L'/'&amp;' find/again; Move sort column: '&lt;'/'&gt;' left/right
  R,H,J,C . Toggle: 'R' Sort; 'H' Threads; 'J' Num justify; 'C' Coordinates
  c,i,S,j . Toggle: 'c' Cmd name/line; 'i' Idle; 'S' Time; 'j' Str justify
  x,y     . Toggle highlights: 'x' sort field; 'y' running tasks
  z,b     . Toggle: 'z' color/mono; 'b' bold/reverse (only if 'x' or 'y')
  u,U,o,O . Filter by: 'u'/'U' effective/any user; 'o'/'O' other criteria
  n,#,^O  . Set: 'n'/'#' max tasks displayed; Show: Ctrl+'O' other filter(s)
  V,v,F   . Toggle: 'V' forest view; 'v' hide/show children; 'F' keep focused

  d,k,r,^R 'd' set delay; 'k' kill; 'r' renice; Ctrl+'R' renice autogroup
  ^G,K,N,U  View: ctl groups ^G; cmdline ^K; environment ^N; supp groups ^U
  Y,!,^E,P  Inspect 'Y'; Combine Cpus '!'; Scale time ^E; View namespaces ^P
  W,q       Write config file 'W'; Quit 'q'
          ( commands shown with '.' require a visible task display window ) 
Press 'h' or '?' for help with Windows,

</code></pre></div></div> <p>htop会更现代一些：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ htop  --help
htop 3.3.0
(C) 2004-2019 Hisham Muhammad. (C) 2020-2024 htop dev team.
Released under the GNU GPLv2+.

-C --no-color                   Use a monochrome color scheme
-d --delay=DELAY                Set the delay between updates, in tenths of seconds
-F --filter=FILTER              Show only the commands matching the given filter
-h --help                       Print this help screen
-H --highlight-changes[=DELAY]  Highlight new and old processes
-M --no-mouse                   Disable the mouse
-n --max-iterations=NUMBER      Exit htop after NUMBER iterations/frame updates
-p --pid=PID[,PID,PID...]       Show only the given PIDs
   --readonly                   Disable all system and process changing features
-s --sort-key=COLUMN            Sort by COLUMN in list view (try --sort-key=help for a list)
-t --tree                       Show the tree view (can be combined with -s)
-u --user[=USERNAME]            Show only processes for a given user (or $USER)
-U --no-unicode                 Do not use unicode but plain ASCII
-V --version                    Print version info
   --drop-capabilities[=off|basic|strict] Drop Linux capabilities when running as root
                                off - do not drop any capabilities
                                basic (default) - drop all capabilities not needed by htop
                                strict - drop all capabilities except those needed for
                                         core functionality

</code></pre></div></div> <h1 id="system-information">System Information</h1> <p>这方面的工具可就太多了，列举几个常用的吧。</p> <h2 id="进程运行相关的">进程运行相关的</h2> <p><code class="language-plaintext highlighter-rouge">pidstat</code>也是sysstat的成员，</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PIDSTAT(1)                                                                Linux User's Manual                                                                PIDSTAT(1)

NAME
       pidstat - Report statistics for Linux tasks.

SYNOPSIS
       pidstat [ -d ] [ -H ] [ -h ] [ -I ] [ -l ] [ -R ] [ -r ] [ -s ] [ -t ] [ -U [ username ] ] [ -u ] [ -V ] [ -v ] [ -w ] [ -C comm ] [ -G process_name ] [ --dec={
       0 | 1 | 2 } ] [ --human ] [ -p { pid[,...]  | SELF | ALL } ] [ -T { TASK | CHILD | ALL } ] [ interval [ count ] ] [ -e program args ]

DESCRIPTION
	pidstat用于监视被kernel管理的独立的进程，-T输出进程树，-l查看进程的所带参数,-d选择特定项展示
	
</code></pre></div></div> <p>还有一般系统自带命令<code class="language-plaintext highlighter-rouge">ps</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXAMPLES
       To see every process on the system using standard syntax:
          ps -e
          ps -ef
          ps -eF
          ps -ely

       To see every process on the system using BSD syntax:
          ps ax
          ps axu

       To print a process tree:
          ps -ejH
          ps axjf

       To get info about threads:
          ps -eLf
          ps axms

       To get security info:
          ps -eo euser,ruser,suser,fuser,f,comm,label
          ps axZ
          ps -eM

       To see every process running as root (real &amp; effective ID) in user format:
          ps -U root -u root u

       To see every process with a user-defined format:
          ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm
          ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
          ps -Ao pid,tt,user,fname,tmout,f,wchan

       Print only the process IDs of syslogd:
          ps -C syslogd -o pid=

       Print only the name of PID 42:
          ps -q 42 -o comm=
</code></pre></div></div> <p>要具体分析某一个进程的所有参数，使用的环境变量等，我们可以查看<code class="language-plaintext highlighter-rouge">/proc/[pid]</code>的文件内容。比如chrome的进程详情：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 24038   20648  0  80   0 - 8617004 do_sys 18:26 ?      00:00:38 /opt/google/chrome/chrome
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ➜  24038 pwd
/proc/24038
➜  24038 ls
arch_status  clear_refs          cpuset   fdinfo             latency    mem         ns             pagemap      sched      smaps_rollup  syscall         uid_map
attr         cmdline             cwd      gid_map            limits     mountinfo   numa_maps      patch_state  schedstat  stack         task            wchan
autogroup    comm                environ  io                 loginuid   mounts      oom_adj        personality  sessionid  stat          timens_offsets
auxv         coredump_filter     exe      ksm_merging_pages  map_files  mountstats  oom_score      projid_map   setgroups  statm         timers
cgroup       cpu_resctrl_groups  fd       ksm_stat           maps       net         oom_score_adj  root         smaps      status        timerslack_ns
</code></pre></div></div> <p>进程的资源限制</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  24038 cat limits 
Limit                     Soft Limit           Hard Limit           Units     
Max cpu time              unlimited            unlimited            seconds   
Max file size             unlimited            unlimited            bytes     
Max data size             unlimited            unlimited            bytes     
Max stack size            8388608              unlimited            bytes     
Max core file size        unlimited            unlimited            bytes     
Max resident set          unlimited            unlimited            bytes     
Max processes             63276                63276                processes 
Max open files            8192                 524288               files     
Max locked memory         8388608              8388608              bytes     
Max address space         unlimited            unlimited            bytes     
Max file locks            unlimited            unlimited            locks     
Max pending signals       63276                63276                signals   
Max msgqueue size         819200               819200               bytes     
Max nice priority         0                    0                    
Max realtime priority     0                    0                    
Max realtime timeout      200000               200000               us 
</code></pre></div></div> <p>进程的内存映射</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
.......
55c9d36bd000-55c9d6073000 r--p 00000000 00:21 313220                     /opt/google/chrome/chrome
55c9d6074000-55c9e15cb000 r-xp 029b6000 00:21 313220                     /opt/google/chrome/chrome
55c9e15cb000-55c9e1f3b000 r--p 0df0c000 00:21 313220                     /opt/google/chrome/chrome
55c9e1f3c000-55c9e1fdb000 rw-p 0e87c000 00:21 313220                     /opt/google/chrome/chrome
55c9e1fdb000-55c9e2216000 rw-p 00000000 00:00 0 
7f67e89fd000-7f67e8dfe000 rw-s 00000000 00:19 31189                      /dev/shm/.com.google.Chrome.2paG6K (deleted)
7f67e91ff000-7f67e93ff000 rw-s 00000000 00:19 25205                      /dev/shm/.com.google.Chrome.85mbcU (deleted)
7f67e97ff000-7f67e9c00000 rw-s 00000000 00:19 31628                      /dev/shm/.com.google.Chrome.KMf8KM (deleted)
7f67e9c00000-7f67e9e00000 rw-s 00000000 00:19 31123                      /dev/shm/.com.google.Chrome.TQYc44 (deleted)
7f67e9e00000-7f67ea000000 rw-s 00000000 00:19 28885                      /dev/shm/.com.google.Chrome.a3yoDs (deleted)
7f67ea000000-7f67ea001000 ---p 00000000 00:00 0 
7f67ea001000-7f67ea801000 rw-p 00000000 00:00 0 
7f67eaa00000-7f67eac00000 rw-s 00000000 00:19 27993                      /dev/shm/.com.google.Chrome.lLMoFU (deleted)
7f67eac00000-7f67eae00000 rw-s 00000000 00:19 28881                      /dev/shm/.com.google.Chrome.F0dyOY (deleted)
7f67eae00000-7f67eb000000 rw-s 00000000 00:19 30033                      /dev/shm/.com.google.Chrome.1Voh8V (deleted)
7f67eb000000-7f67eb254000 r--p 00000000 00:21 66406                      /usr/share/fonts/gdouros-symbola/Symbola.ttf
7f67eb400000-7f67eb401000 ---p 00000000 00:00 0 
7f67eb401000-7f67ebc01000 rw-p 00000000 00:00 0 
7f67ebe00000-7f67ec000000 rw-s 00000000 00:19 26544                      /dev/shm/.com.google.Chrome.09l3Mp (deleted)
7f67ec000000-7f67ec200000 rw-s 00000000 00:19 24984                      /dev/shm/.com.google.Chrome.jybCNY (deleted)
7f67ec200000-7f67ec201000 ---p 00000000 00:00 0 
7f67ec201000-7f67eca01000 rw-p 00000000 00:00 0 
7f67ecc00000-7f67ecc01000 ---p 00000000 00:00 0 
7f67ecc01000-7f67ed401000 rw-p 00000000 00:00 0 
7f67ed600000-7f67ed601000 ---p 00000000 00:00 0 
7f67ed601000-7f67ede01000 rw-p 00000000 00:00 0 
7f67ee000000-7f67ee001000 ---p 00000000 00:00 0 
7f67ee001000-7f67ee801000 rw-p 00000000 00:00 0 
7f67eea00000-7f67eea01000 ---p 00000000 00:00 0 
7f67eea01000-7f67ef201000 rw-p 00000000 00:00 0 
7f67ef400000-7f67ef7d9000 r--p 00000000 00:21 66449                      /usr/share/fonts/google-droid-sans-fonts/DroidSansFallbackFull.ttf

.......
</code></pre></div></div> <p>进程使用的系统当前挂载信息</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ➜  24038 cat mountinfo 
66 1 0:33 /root / rw,relatime shared:1 - btrfs /dev/nvme0n1p3 rw,seclabel,compress=zstd:1,ssd,discard=async,space_cache=v2,subvolid=257,subvol=/root
35 66 0:6 / /dev rw,nosuid shared:2 - devtmpfs devtmpfs rw,seclabel,size=4096k,nr_inodes=2024848,mode=755,inode64
36 35 0:25 / /dev/shm rw,nosuid,nodev shared:3 - tmpfs tmpfs rw,seclabel,inode64
37 35 0:26 / /dev/pts rw,nosuid,noexec,relatime shared:4 - devpts devpts rw,seclabel,gid=5,mode=620,ptmxmode=000
38 66 0:24 / /sys rw,nosuid,nodev,noexec,relatime shared:5 - sysfs sysfs rw,seclabel
39 38 0:7 / /sys/kernel/security rw,nosuid,nodev,noexec,relatime shared:6 - securityfs securityfs rw
40 38 0:28 / /sys/fs/cgroup rw,nosuid,nodev,noexec,relatime shared:7 - cgroup2 cgroup2 rw,seclabel,nsdelegate,memory_recursiveprot
41 38 0:29 / /sys/fs/pstore rw,nosuid,nodev,noexec,relatime shared:8 - pstore pstore rw,seclabel
42 38 0:30 / /sys/firmware/efi/efivars rw,nosuid,nodev,noexec,relatime shared:9 - efivarfs efivarfs rw
43 38 0:31 / /sys/fs/bpf rw,nosuid,nodev,noexec,relatime shared:10 - bpf bpf rw,mode=700
44 38 0:32 / /sys/kernel/config rw,nosuid,nodev,noexec,relatime shared:11 - configfs configfs rw
45 66 0:23 / /proc rw,nosuid,nodev,noexec,relatime shared:13 - proc proc rw
46 66 0:27 / /run rw,nosuid,nodev shared:14 - tmpfs tmpfs rw,seclabel,size=3248648k,nr_inodes=819200,mode=755,inode64
25 38 0:21 / /sys/fs/selinux rw,nosuid,noexec,relatime shared:12 - selinuxfs selinuxfs rw
24 45 0:36 / /proc/sys/fs/binfmt_misc rw,relatime shared:15 - autofs systemd-1 rw,fd=37,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=6661
27 35 0:37 / /dev/hugepages rw,nosuid,nodev,relatime shared:16 - hugetlbfs hugetlbfs rw,seclabel,pagesize=2M
28 35 0:20 / /dev/mqueue rw,nosuid,nodev,noexec,relatime shared:17 - mqueue mqueue rw,seclabel
31 38 0:8 / /sys/kernel/debug rw,nosuid,nodev,noexec,relatime shared:18 - debugfs none rw,seclabel
32 38 0:13 / /sys/kernel/tracing rw,nosuid,nodev,noexec,relatime shared:19 - tracefs tracefs rw,seclabel
33 38 0:38 / /sys/fs/fuse/connections rw,nosuid,nodev,noexec,relatime shared:20 - fusectl fusectl rw
48 66 0:33 /home /home rw,relatime shared:73 - btrfs /dev/nvme0n1p3 rw,seclabel,compress=zstd:1,ssd,discard=async,space_cache=v2,subvolid=256,subvol=/home
51 66 0:42 / /tmp rw,nosuid,nodev shared:76 - tmpfs tmpfs rw,seclabel,nr_inodes=1048576,inode64
54 66 259:2 / /boot rw,relatime shared:79 - ext4 /dev/nvme0n1p2 rw,seclabel
57 54 259:1 / /boot/efi rw,relatime shared:82 - vfat /dev/nvme0n1p1 rw,fmask=0077,dmask=0077,codepage=437,iocharset=ascii,shortname=winnt,errors=remount-ro
60 24 0:43 / /proc/sys/fs/binfmt_misc rw,nosuid,nodev,noexec,relatime shared:85 - binfmt_misc binfmt_misc rw
143 66 0:50 / /var/lib/nfs/rpc_pipefs rw,relatime shared:174 - rpc_pipefs sunrpc rw
26 46 0:82 / /run/user/1000 rw,nosuid,nodev,relatime shared:1041 - tmpfs tmpfs rw,seclabel,size=1624320k,nr_inodes=406080,mode=700,uid=1000,gid=1000,inode64
318 26 0:83 / /run/user/1000/gvfs rw,nosuid,nodev,relatime shared:1045 - fuse.gvfsd-fuse gvfsd-fuse rw,user_id=1000,group_id=1000
1203 26 0:84 / /run/user/1000/doc rw,nosuid,nodev,relatime shared:1127 - fuse.portal portal rw,user_id=1000,group_id=1000

</code></pre></div></div> <h2 id="设备状态信息">设备状态信息</h2> <p>可以使用sysstat里的iostat</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IOSTAT(1)                                                                 Linux User's Manual                                                                 IOSTAT(1)

NAME
       iostat - Report Central Processing Unit (CPU) statistics and input/output statistics for devices and partitions.

SYNOPSIS
       iostat  [ -c ] [ -d ] [ -h ] [ -k | -m ] [ -N ] [ -s ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ] [ --compact ] [ --dec={ 0 | 1 | 2 } ] [ { -f | +f } directory ] [ -j {
       ID | LABEL | PATH | UUID | ... } ] [ -o JSON ] [ [ -H ] -g group_name ] [ --human ] [ --pretty ] [ -p [ device[,...] | ALL ] ] [ device [...] | ALL ] [ interval
       [ count ] ]

DESCRIPTION
		iostat通过观察io设备在它们使用时间内的数据传输效率，
</code></pre></div></div> <p>输出</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ iostat -x 
Linux 6.10.4-200.fc40.x86_64 (fedora)   08/18/2024      _x86_64_        (8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.76    0.01    0.74    0.26    0.00   97.23

Device            r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util
nvme0n1          0.54     23.88     0.08  12.56    1.00    44.36    8.19    123.21     0.18   2.15    2.55    15.05    0.03    145.84     0.00   0.00    1.72  5216.03    0.29    3.29    0.02   0.29
zram0            0.00      0.01     0.00   0.00    0.00    21.85    0.00      0.00     0.00   0.00    0.00     4.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00

</code></pre></div></div> <p>也可以在一定时间内采集指定次数的数据。 然后还有<code class="language-plaintext highlighter-rouge">/dev</code>目录下，使用的字符设备和块设备会在此处创建设备节点文件。/dev主要是为系统提供设备的访问节点，而/sys文件系统比/dev要更新，且携带了设备的更多信息。比如cpu</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  /sys cat ./devices/system/cpu/cpufreq/policy0/scaling_cur_freq 
3601102
➜  /sys cat ./devices/system/cpu/cpufreq/policy7/cpuinfo_transition_latency 
0
➜  /sys cat ./devices/system/cpu/cpufreq/policy7/cpuinfo_max_freq
3600000
➜  /sys 

</code></pre></div></div> <p>内存</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  /sys cat ./devices/system/memory/block_size_bytes 
8000000
➜  /sys cat ./devices/system/memory/auto_online_blocks 
online

</code></pre></div></div> <p>网卡</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  /sys cat  ./class/net/enp0s31f6/mtu 
1500
➜  /sys cat  ./class/net/enp0s31f6/speed 
-1
</code></pre></div></div> <p>当然了，也可以直接往/sys系统的设备文件内写值来配置设备.</p> <h2 id="查看日志">查看日志</h2> <p>查看内核<code class="language-plaintext highlighter-rouge">dmesg</code><br/> 其他日志<code class="language-plaintext highlighter-rouge">journalctl</code></p> <h2 id="网络相关">网络相关</h2> <p>查看当前所有设备、ip地址可以使用iproute2包的内容：<code class="language-plaintext highlighter-rouge">ip a</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host noprefixroute 
       valid_lft forever preferred_lft forever
2: enp0s31f6: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
    link/ether c8:f7:50:68:cc:ac brd ff:ff:ff:ff:ff:ff  
</code></pre></div></div> <p>一般比较新的系统会使用Networkmanager管理网络，所以可以使用<code class="language-plaintext highlighter-rouge">nmcli </code>相关指令<br/> 然后是查看当前系统网络监听的TCP/UDP端口 <code class="language-plaintext highlighter-rouge">netstat -tulp</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ netstat -tulp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:llmnr           0.0.0.0:*               LISTEN      -                   
tcp        0      0 _localdnsstub:domain    0.0.0.0:*               LISTEN      -                   
tcp        0      0 _localdnsproxy:domain   0.0.0.0:*               LISTEN      -                   
tcp        0      0 localhost:33211         0.0.0.0:*               LISTEN      -                   

</code></pre></div></div> <p>也可以使用更新的<code class="language-plaintext highlighter-rouge">ss -tulpn</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Netid      State       Recv-Q      Send-Q                                Local Address:Port            Peer Address:Port      Process                                       
udp        UNCONN      0           0                                       224.0.0.251:5353                 0.0.0.0:*          users:(("chrome",pid=24038,fd=185))          
udp        UNCONN      0           0                                       224.0.0.251:5353                 0.0.0.0:*          users:(("chrome",pid=24038,fd=120))          
udp        UNCONN      0           0                                           0.0.0.0:5353                 0.0.0.0:*                                                       
udp        UNCONN      0           0                                           0.0.0.0:5355                 0.0.0.0:*                                                       
udp        UNCONN      0           0                                        127.0.0.54:53                   0.0.0.0:*                                                       
udp        UNCONN      0           0                                     127.0.0.53%lo:53                   0.0.0.0:*                                                       
udp        UNCONN      0           0                                         127.0.0.1:323                  0.0.0.0:*                                                       
udp        UNCONN      0           0                                           0.0.0.0:44214                0.0.0.0:*                                                       
udp        UNCONN      0           0                                              [::]:5353                    [::]:*                                                       
udp        UNCONN      0           0                                              [::]:5355                    [::]:*                                                       
</code></pre></div></div> <p>还有<code class="language-plaintext highlighter-rouge">lsof</code>,列出所有打开的文件</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ➜  ~ lsof -i
COMMAND     PID      USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
gnome-she 20648 jlibyvali   62u  IPv4 371625      0t0  TCP localhost:41902-&gt;localhost:7897 (ESTABLISHED)
</code></pre></div></div> <p>还有手动的，可以查看<code class="language-plaintext highlighter-rouge">/proc/net</code>下和<code class="language-plaintext highlighter-rouge">/sys/class/net/</code>下的文件信息</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  net pwd
/proc/net
➜  net ls
anycast6   dev_snmp6     if_inet6       ip6_tables_matches  ip_tables_names    netfilter            protocols  route      snmp          tcp       unix
arp        fib_trie      igmp           ip6_tables_names    ip_tables_targets  netlink              psched     rpc        snmp6         tcp6      wireless
bnep       fib_triestat  igmp6          ip6_tables_targets  ipv6_route         netstat              ptype      rt6_stats  sockstat      udp       xfrm_stat
connector  hci           ip6_flowlabel  ip_mr_cache         l2cap              nf_conntrack         raw        rt_acct    sockstat6     udp6
dev        icmp          ip6_mr_cache   ip_mr_vif           mcfilter           nf_conntrack_expect  raw6       rt_cache   softnet_stat  udplite
dev_mcast  icmp6         ip6_mr_vif     ip_tables_matches   mcfilter6          packet               rfcomm     sco        stat          udplite6

➜  net pwd
/sys/class/net
➜  net ls 
enp0s31f6  lo  wlp2s0

</code></pre></div></div> <p>dns相关的<code class="language-plaintext highlighter-rouge">nslookup</code>和<code class="language-plaintext highlighter-rouge">dig</code> ,测试ssl连接的<code class="language-plaintext highlighter-rouge">openssl client</code> <br/> dns配置常用的有systemd-resolved,Networkmanager,dnsmasq。<strong>推荐资料</strong>:<br/> <a href="https://wiki.archlinux.org/title/Systemd-resolved">https://wiki.archlinux.org/title/Systemd-resolved</a> <a href="https://www.freedesktop.org/software/systemd/man/latest/resolved.conf.html">https://www.freedesktop.org/software/systemd/man/latest/resolved.conf.html</a> <a href="https://wiki.archlinux.org/title/NetworkManager">https://wiki.archlinux.org/title/NetworkManager</a> <a href="https://wiki.archlinux.org/title/Dnsmasq">https://wiki.archlinux.org/title/Dnsmasq</a></p> <p>感觉使用默认的systemd-resolved或者Networkmanager是比较简单的，当然注意有些代理软件会劫持dns，关闭代理后需要刷新本地dns服务器缓存。<br/> 然后是防火墙的Debian/Ubuntu常用ufw。其他的firewall-cmd,还有手动的iptables</p> <h2 id="系统相关的服务守护进程uevent事件管理">系统相关的服务,守护进程，uevent事件管理。</h2> <p>对于有使用<code class="language-plaintext highlighter-rouge">systemd</code>的系统，可以方便的使用<code class="language-plaintext highlighter-rouge">systemctl list-units --type=service</code> 查看所有服务</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ systemctl list-units --type=service 
  UNIT                                                                                      LOAD   ACTIVE SUB     DESCRIPTION                                              &gt;
  abrt-journal-core.service                                                                 loaded active running ABRT coredumpctl message creator
  abrt-oops.service                                                                         loaded active running ABRT kernel log watcher
  abrt-xorg.service                                                                         loaded active running ABRT Xorg log watcher
  abrtd.service                                                                             loaded active running ABRT Daemon
  accounts-daemon.service                                                                   loaded active running Accounts Service
  alsa-state.service                                                                        loaded active running Manage Sound Card State (restore and store)
  auditd.service                                                                            loaded active running Security Audit Logging Service

</code></pre></div></div> <p>对于守护进程,一般以<code class="language-plaintext highlighter-rouge">d</code>结尾i，ps 加 grep筛选即可<br/> 对于uevents事件监控，<code class="language-plaintext highlighter-rouge">sudo udeadmin monitor</code>,此时可以插入一个u盘查看事件。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ sudo udevadm monitor 
monitor will print the received events for:
UDEV - the event which udev sends out after rule processing
KERNEL - the kernel uevent

KERNEL[11523.441106] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9 (usb)
KERNEL[11523.444999] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0 (usb)
KERNEL[11523.445204] add      /devices/virtual/workqueue/scsi_tmf_0 (workqueue)
KERNEL[11523.445239] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0 (scsi)
KERNEL[11523.445263] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/scsi_host/host0 (scsi_host)
KERNEL[11523.445299] bind     /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0 (usb)
KERNEL[11523.445337] bind     /devices/pci0000:00/0000:00:14.0/usb1/1-9 (usb)
UDEV  [11523.446523] add      /devices/virtual/workqueue/scsi_tmf_0 (workqueue)
UDEV  [11523.451793] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9 (usb)
UDEV  [11523.453725] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0 (usb)
UDEV  [11523.454829] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0 (scsi)
UDEV  [11523.455897] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/scsi_host/host0 (scsi_host)
UDEV  [11523.456765] bind     /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0 (usb)
UDEV  [11523.460665] bind     /devices/pci0000:00/0000:00:14.0/usb1/1-9 (usb)
KERNEL[11524.783262] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0 (scsi)
KERNEL[11524.783316] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0 (scsi)
KERNEL[11524.783350] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)
KERNEL[11524.783387] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/scsi_disk/0:0:0:0 (scsi_disk)
KERNEL[11524.783428] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/scsi_generic/sg0 (scsi_generic)
KERNEL[11524.783603] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)
UDEV  [11524.785215] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0 (scsi)
UDEV  [11524.786484] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0 (scsi)
KERNEL[11524.792336] add      /devices/virtual/bdi/8:0 (bdi)
KERNEL[11524.803394] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/block/sda (block)
KERNEL[11524.803450] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/block/sda/sda1 (block)
KERNEL[11524.803483] bind     /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0 (scsi)
UDEV  [11524.804755] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)
UDEV  [11524.804791] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/scsi_disk/0:0:0:0 (scsi_disk)
UDEV  [11524.806448] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/scsi_generic/sg0 (scsi_generic)
UDEV  [11524.807463] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)
UDEV  [11524.809118] add      /devices/virtual/bdi/8:0 (bdi)
UDEV  [11524.931275] add      /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/host0/target0:0:0/0:0:0:0/block/sda (block)

</code></pre></div></div> <h2 id="对于ipc资源的使用">对于IPC资源的使用</h2> <p><code class="language-plaintext highlighter-rouge">ipcs</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ipcs
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x00000000 65536      tux        600        524288     2          dest
0x00000000 98305      tux        600        4194304    2          dest
0x00000000 884738     root       600        524288     2          dest
0x00000000 786435     tux        600        4194304    2          dest
0x00000000 12058628   tux        600        524288     2          dest
0x00000000 917509     root       600        524288     2          dest
0x00000000 12353542   tux        600        196608     2          dest
0x00000000 12451847   tux        600        524288     2          dest
0x00000000 11567114   root       600        262144     1          dest
0x00000000 10911763   tux        600        2097152    2          dest
0x00000000 11665429   root       600        2336768    2          dest
0x00000000 11698198   root       600        196608     2          dest
0x00000000 11730967   root       600        524288     2          dest

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0xa12e0919 32768      tux        666        2
</code></pre></div></div> <h2 id="lsxx系列">lsxx系列</h2> <p>比如<code class="language-plaintext highlighter-rouge">lsblk</code>,<code class="language-plaintext highlighter-rouge">lsclocks</code>,<code class="language-plaintext highlighter-rouge">lscpu</code>,<code class="language-plaintext highlighter-rouge">lsmem</code>,<code class="language-plaintext highlighter-rouge">lsmdev</code>,<code class="language-plaintext highlighter-rouge">lsmod</code>等等，这些命令一般随系统自带，位于软件包<code class="language-plaintext highlighter-rouge">util-linux</code>中。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ lscpu
Architecture:             x86_64
  CPU op-mode(s):         32-bit, 64-bit
  Address sizes:          39 bits physical, 48 bits virtual
  Byte Order:             Little Endian
CPU(s):                   8
  On-line CPU(s) list:    0-7
Vendor ID:                GenuineIntel
  Model name:             Intel(R) Core(TM) i5-8350U CPU @ 1.70GHz
    CPU family:           6
    Model:                142
    Thread(s) per core:   2
    Core(s) per socket:   4
    Socket(s):            1
    Stepping:             10
    CPU(s) scaling MHz:   78%
    CPU max MHz:          3600.0000
    CPU min MHz:          400.0000
    BogoMIPS:             3799.90
    Flags:                fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp 
                          lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2
                           ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid
                          _fault epb pti ssbd ibrs ibpb stibp tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx rdseed adx sm
                          ap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp vnmi md_clear flush_l1d arch_c
                          apabilities
Virtualization features:  
  Virtualization:         VT-x
Caches (sum of all):      
  L1d:                    128 KiB (4 instances)
  L1i:                    128 KiB (4 instances)
  L2:                     1 MiB (4 instances)
  L3:                     6 MiB (1 instance)
NUMA:                     
  NUMA node(s):           1
  NUMA node0 CPU(s):      0-7
Vulnerabilities:          
  Gather data sampling:   Mitigation; Microcode
  Itlb multihit:          KVM: Mitigation: VMX disabled
  L1tf:                   Mitigation; PTE Inversion; VMX conditional cache flushes, SMT vulnerable
  Mds:                    Mitigation; Clear CPU buffers; SMT vulnerable
  Meltdown:               Mitigation; PTI
  Mmio stale data:        Mitigation; Clear CPU buffers; SMT vulnerable
  Reg file data sampling: Not affected
  Retbleed:               Mitigation; IBRS
  Spec rstack overflow:   Not affected
  Spec store bypass:      Mitigation; Speculative Store Bypass disabled via prctl
  Spectre v1:             Mitigation; usercopy/swapgs barriers and __user pointer sanitization
  Spectre v2:             Mitigation; IBRS; IBPB conditional; STIBP conditional; RSB filling; PBRSB-eIBRS Not affected; BHI Not affected
  Srbds:                  Mitigation; Microcode
  Tsx async abort:        Mitigation; TSX disabled

</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ lspci
00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v6/7th Gen Core Processor Host Bridge/DRAM Registers (rev 08)
00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 620 (rev 07)
00:04.0 Signal processing controller: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem (rev 08)
00:14.0 USB controller: Intel Corporation Sunrise Point-LP USB 3.0 xHCI Controller (rev 21)
00:14.2 Signal processing controller: Intel Corporation Sunrise Point-LP Thermal subsystem (rev 21)
00:15.0 Signal processing controller: Intel Corporation Sunrise Point-LP Serial IO I2C Controller #0 (rev 21)
00:15.1 Signal processing controller: Intel Corporation Sunrise Point-LP Serial IO I2C Controller #1 (rev 21)
00:15.2 Signal processing controller: Intel Corporation Sunrise Point-LP Serial IO I2C Controller #2 (rev 21)
00:15.3 Signal processing controller: Intel Corporation Sunrise Point-LP Serial IO I2C Controller #3 (rev 21)
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ lsipc
RESOURCE DESCRIPTION                                              LIMIT USED  USE%
MSGMNI   Number of message queues                                 32000    0 0.00%
MSGMAX   Max size of message (bytes)                                 8K    -     -
MSGMNB   Default max size of queue (bytes)                          16K    -     -
SHMMNI   Shared memory segments                                    4096    0 0.00%
SHMALL   Shared memory pages                       18446744073692774399    0 0.00%
SHMMAX   Max size of shared memory segment (bytes)                  16E    -     -
SHMMIN   Min size of shared memory segment (bytes)                   1B    -     -
SEMMNI   Number of semaphore identifiers                          32000    0 0.00%
SEMMNS   Total number of semaphores                          1024000000    0 0.00%
SEMMSL   Max semaphores per semaphore set.                        32000    -     -
SEMOPM   Max number of operations per semop(2)                      500    -     -
SEMVMX   Semaphore max value                                      32767    -     -

</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ lsirq
IRQ    TOTAL NAME
LOC 14256285 Local timer interrupts
 17  5705206 IR-IO-APIC 17-fasteoi i2c_designware.1, idma64.1
CAL   899517 Function call interrupts
140   817574 IR-PCI-MSI-0000:00:02.0 0-edge i915
IWI   473546 IRQ work interrupts
TLB   420519 TLB shootdowns
  9   406754 IR-IO-APIC 9-fasteoi acpi
142   396167 IR-PCI-MSI-0000:00:1f.6 0-edge enp0s31f6
 51   239162 IR-IO-APIC 51-fasteoi DELL081C:00
133    83699 IR-PCI-MSIX-0000:03:00.0 1-edge nvme0q1
RES    47677 Rescheduling interrupts
136    38973 IR-PCI-MSIX-0000:03:00.0 4-edge nvme0q4
134    37771 IR-PCI-MSIX-0000:03:00.0 2-edge nvme0q2
137    36049 IR-PCI-MSIX-0000:03:00.0 5-edge nvme0q5
139    32324 IR-PCI-MSIX-0000:03:00.0 7-edge nvme0q7
135    30714 IR-PCI-MSIX-0000:03:00.0 3-edge nvme0q3
138    26428 IR-PCI-MSIX-0000:03:00.0 6-edge nvme0q6
  1    11656 IR-IO-APIC 1-edge i8042

......
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ lsmem 
RANGE                                  SIZE  STATE REMOVABLE  BLOCK
0x0000000000000000-0x00000000cfffffff  3.3G online       yes   0-25
0x0000000100000000-0x000000042fffffff 12.8G online       yes 32-133

Memory block size:       128M
Total online memory:      16G
Total offline memory:      0B

</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ lsmod 
Module                  Size  Used by
uas                    36864  0
usb_storage            90112  1 uas
rfcomm                102400  0
tun                    73728  0
uinput                 20480  0
snd_seq_dummy          12288  0
snd_hrtimer            12288  1
nf_conntrack_netbios_ns    12288  1
nf_conntrack_broadcast    12288  1 nf_conntrack_netbios_ns
nft_fib_inet           12288  1
nft_fib_ipv4           12288  1 nft_fib_inet
nft_fib_ipv6           12288  1 nft_fib_inet
nft_fib                12288  3 nft_fib_ipv6,nft_fib_ipv4,nft_fib_inet
nft_reject_inet        12288  10

</code></pre></div></div> <h2 id="procsys">/proc/sys</h2> <p>/proc/sys也称为系统控制参数，用于修饰内核运行时的参数</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ sysctl --help

Usage:
 sysctl [options] [variable[=value] ...]

Options:
  -a, --all            display all variables
  -A                   alias of -a
  -X                   alias of -a
      --deprecated     include deprecated parameters to listing
      --dry-run        Print the key and values but do not write
  -b, --binary         print value without new line
  -e, --ignore         ignore unknown variables errors
  -N, --names          print variable names without values
  -n, --values         print only values of the given variable(s)
  -p, --load[=&lt;file&gt;]  read values from file
  -f                   alias of -p
      --system         read values from all system directories
  -r, --pattern &lt;expression&gt;
                       select setting that match expression
  -q, --quiet          do not echo variable set
  -w, --write          enable writing a value to variable
  -o                   does nothing
  -x                   does nothing
  -d                   alias of -h

 -h, --help     display this help and exit
 -V, --version  output version information and exit

</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">sysctl -a</code>列出所有参数，sysctl将可以修改的参数分组，比如<code class="language-plaintext highlighter-rouge">sysctl fs</code>,<code class="language-plaintext highlighter-rouge">sysctl dev</code>,<code class="language-plaintext highlighter-rouge">sysctl kernel</code>,<code class="language-plaintext highlighter-rouge">sysctl net</code>,<code class="language-plaintext highlighter-rouge">sysctl vm</code>。</p> <h2 id="文件与文件系统">文件与文件系统</h2> <p>文件系统最常用的<code class="language-plaintext highlighter-rouge">mount</code>,<code class="language-plaintext highlighter-rouge">df</code>,<code class="language-plaintext highlighter-rouge">du</code>,<code class="language-plaintext highlighter-rouge">fdisk</code><br/> <code class="language-plaintext highlighter-rouge">mount</code>用于展示系统内所有文件系统的挂载信息，完成挂载相关操作。 <code class="language-plaintext highlighter-rouge">df</code>用于展示主要文件系统的使用量。 <code class="language-plaintext highlighter-rouge">du</code>主要用于计算大小。<br/> 阅读文件相关的命令常用的：<code class="language-plaintext highlighter-rouge">stat</code>,<code class="language-plaintext highlighter-rouge">readelf</code>,分析文件内部的section和symbol的<code class="language-plaintext highlighter-rouge">objdump</code>,<code class="language-plaintext highlighter-rouge">nm</code> <code class="language-plaintext highlighter-rouge">readelf</code>主要查看elf二进制格式文件信息，即使是不同架构的编译产物。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>readelf --file-header /bin/ls
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x402540
  Start of program headers:          64 (bytes into file)
  Start of section headers:          95720 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         32
  Section header string table index: 31
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">stat</code>主要展示文件属性</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  ~ stat ./.zshrc 
  File: ./.zshrc
  Size: 4648            Blocks: 16         IO Block: 4096   regular file
Device: 0,41    Inode: 53136       Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/jlibyvali)   Gid: ( 1000/jlibyvali)
Context: unconfined_u:object_r:user_home_t:s0
Access: 2024-08-18 18:19:30.430482095 +0800
Modify: 2024-08-18 18:18:21.339954059 +0800
Change: 2024-08-18 18:18:21.352953970 +0800
 Birth: 2024-08-18 18:18:21.339954059 +0800

</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">objdump</code>主要用于分析文件的节，头部表信息：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ➜  ~ objdump -h /usr/bin/objdump 

/usr/bin/objdump:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.gnu.property 00000050  0000000000000338  0000000000000338  00000338  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  0000000000000388  0000000000000388  00000388  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .note.ABI-tag 00000020  00000000000003ac  00000000000003ac  000003ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .note.package 0000008c  00000000000003cc  00000000000003cc  000003cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .gnu.hash     00000048  0000000000000458  0000000000000458  00000458  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .dynsym       00001050  00000000000004a0  00000000000004a0  000004a0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dynstr       00000a00  00000000000014f0  00000000000014f0  000014f0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .gnu.version  0000015c  0000000000001ef0  0000000000001ef0  00001ef0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .gnu.version_r 00000120  0000000000002050  0000000000002050  00002050  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .rela.dyn     00000150  0000000000002170  0000000000002170  00002170  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .rela.plt     00000ee8  00000000000022c0  00000000000022c0  000022c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .relr.dyn     00000118  00000000000031a8  00000000000031a8  000031a8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .init         0000001b  0000000000004000  0000000000004000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .plt          00000a00  0000000000004020  0000000000004020  00004020  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .plt.sec      000009f0  0000000000004a20  0000000000004a20  00004a20  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text         00046424  0000000000005410  0000000000005410  00005410  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .fini         0000000d  000000000004b834  000000000004b834  0004b834  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .rodata       000152d3  000000000004c000  000000000004c000  0004c000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 19 .eh_frame_hdr 000008e4  00000000000612d4  00000000000612d4  000612d4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 20 .eh_frame     0000307c  0000000000061bb8  0000000000061bb8  00061bb8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 21 .init_array   00000008  00000000000652b0  00000000000652b0  000652b0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 22 .fini_array   00000008  00000000000652b8  00000000000652b8  000652b8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 23 .data.rel.ro  00002580  00000000000652c0  00000000000652c0  000652c0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 24 .dynamic      00000270  0000000000067840  0000000000067840  00067840  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 25 .got          00000548  0000000000067ab0  0000000000067ab0  00067ab0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 26 .data         00001d90  0000000000068000  0000000000068000  00068000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 27 .bss          00002e48  0000000000069da0  0000000000069da0  00069d90  2**5
                  ALLOC
 28 .gnu.build.attributes 00000048  000000000006ebe8  000000000006ebe8  00069d90  2**2
                  CONTENTS, READONLY, OCTETS
 29 .gnu_debuglink 00000028  0000000000000000  0000000000000000  00069dd8  2**2
                  CONTENTS, READONLY
 30 .gnu_debugdata 0000119c  0000000000000000  0000000000000000  00069e00  2**0
                  CONTENTS, READONLY
</code></pre></div></div> <p>也可以用于反汇编，查看节的具体内容等。<br/> <code class="language-plaintext highlighter-rouge">nm</code>主要用于分析文件的符号表信息，当然这得要求程序在编译时保留了符号信息，不然是没有的。</p> <hr/> <h1 id="user-information">User Information</h1> <p><code class="language-plaintext highlighter-rouge">fuser</code>,能检测是哪个用户的或进程正在占用该文件，比如要<code class="language-plaintext highlighter-rouge">umount /mnt/*</code>时显示<code class="language-plaintext highlighter-rouge">xxx is busy</code>，使用fuser可以查看是谁在使用它。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fuser -v /mnt/*

                     USER        PID ACCESS COMMAND
/mnt/notes.txt       tux    26597 f....  less
</code></pre></div></div> <h2 id="时间地区其它">时间地区其它</h2> <p><code class="language-plaintext highlighter-rouge">timedatactl</code>可以显示现在的时区，控制日期时间。<br/> <code class="language-plaintext highlighter-rouge">localectl</code>用于控制当前的区域，语言设置。 <code class="language-plaintext highlighter-rouge">hostnamectl</code>用于显示，设置当前机器的主机名字。<br/> 还有用户程序相关的配置文件，程序数据存放路径有关的<code class="language-plaintext highlighter-rouge">XDG env</code>系列： <strong><a href="https://specifications.freedesktop.org/basedir-spec/latest">https://specifications.freedesktop.org/basedir-spec/latest</a></strong></p> <blockquote> <p>内容文字较多，难免遗漏、出错，欢迎斧正</p> </blockquote> <h1 id="参考资料">参考资料</h1> <ul> <li><a href="https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/cha-util.html">https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/cha-util.html</a></li> <li><a href="https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/cha-tuning-syslog.html">https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/cha-tuning-syslog.html</a></li> <li><a href="https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/part-tuning-kerneltrace.html">https://doc.opensuse.org/documentation/leap/tuning/html/book-tuning/part-tuning-kerneltrace.html</a></li> </ul>]]></content><author><name></name></author><category term="system"/><category term="linux"/><summary type="html"><![CDATA[record common vscode configuration]]></summary></entry><entry><title type="html">C/CPP VSCode configure</title><link href="https://jlibyvali.github.io/blog/2024/code/" rel="alternate" type="text/html" title="C/CPP VSCode configure"/><published>2024-07-15T15:09:00+00:00</published><updated>2024-07-15T15:09:00+00:00</updated><id>https://jlibyvali.github.io/blog/2024/code</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2024/code/"><![CDATA[<h1 id="link">Link</h1> <blockquote> <p>See <a href="https://blog.csdn.net/qq_35721063/article/details/141244032">https://blog.csdn.net/qq_35721063/article/details/141244032</a></p> </blockquote>]]></content><author><name></name></author><category term="code"/><category term="vscode"/><summary type="html"><![CDATA[Some configurations for vscode develop quickly.]]></summary></entry><entry><title type="html">Expanded Main Page - OSDev Wiki</title><link href="https://jlibyvali.github.io/blog/2023/expanded-main-page-osdev-wiki/" rel="alternate" type="text/html" title="Expanded Main Page - OSDev Wiki"/><published>2023-12-23T00:00:00+00:00</published><updated>2023-12-23T00:00:00+00:00</updated><id>https://jlibyvali.github.io/blog/2023/expanded-main-page---osdev-wiki</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2023/expanded-main-page-osdev-wiki/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Opensuse Network Configuration</title><link href="https://jlibyvali.github.io/blog/2023/opensuse-network/" rel="alternate" type="text/html" title="Opensuse Network Configuration"/><published>2023-12-10T15:40:10+00:00</published><updated>2023-12-10T15:40:10+00:00</updated><id>https://jlibyvali.github.io/blog/2023/opensuse-network</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2023/opensuse-network/"><![CDATA[<h1 id="link">Link</h1> <blockquote> <p>See<br/> <a href="https://blog.csdn.net/qq_35721063/article/details/136987337">https://blog.csdn.net/qq_35721063/article/details/136987337</a></p> </blockquote>]]></content><author><name></name></author><category term="system"/><category term="network"/><summary type="html"><![CDATA[recording the common NetworkManger configuration]]></summary></entry><entry><title type="html">clash verge tun mode</title><link href="https://jlibyvali.github.io/blog/2023/clah-verge/" rel="alternate" type="text/html" title="clash verge tun mode"/><published>2023-05-12T10:11:12+00:00</published><updated>2023-05-12T10:11:12+00:00</updated><id>https://jlibyvali.github.io/blog/2023/clah-verge</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2023/clah-verge/"><![CDATA[<h1 id="link">Link</h1> <blockquote> <p>See<br/> <a href="https://blog.csdn.net/qq_35721063/article/details/136724819">https://blog.csdn.net/qq_35721063/article/details/136724819</a>c</p> </blockquote>]]></content><author><name></name></author><category term="system"/><category term="network"/><summary type="html"><![CDATA[Link See https://blog.csdn.net/qq_35721063/article/details/136724819c]]></summary></entry><entry><title type="html">Courses for Undergraduates [IPADS]</title><link href="https://jlibyvali.github.io/blog/2023/courses-for-undergraduates-ipads/" rel="alternate" type="text/html" title="Courses for Undergraduates [IPADS]"/><published>2023-05-11T00:00:00+00:00</published><updated>2023-05-11T00:00:00+00:00</updated><id>https://jlibyvali.github.io/blog/2023/courses-for-undergraduates-ipads</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2023/courses-for-undergraduates-ipads/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">clash verge tun mode</title><link href="https://jlibyvali.github.io/blog/2022/esp32-arduino/" rel="alternate" type="text/html" title="clash verge tun mode"/><published>2022-09-21T10:11:12+00:00</published><updated>2022-09-21T10:11:12+00:00</updated><id>https://jlibyvali.github.io/blog/2022/esp32-arduino</id><content type="html" xml:base="https://jlibyvali.github.io/blog/2022/esp32-arduino/"><![CDATA[<h1 id="link">Link</h1> <blockquote> <p>See<br/> <a href="https://blog.csdn.net/qq_35721063/article/details/136812753">https://blog.csdn.net/qq_35721063/article/details/136812753</a></p> </blockquote>]]></content><author><name></name></author><category term="embedded"/><category term="esp32"/><summary type="html"><![CDATA[Link See https://blog.csdn.net/qq_35721063/article/details/136812753]]></summary></entry></feed>
---
layout: post
title: KMP/BM String Match Algorithm
date: 2025-01-10 21:01:00
description: Recording the algorithm implementation
tags: algorithm
categories: code
thumbnail: assets/img/bm_kmp/long_bm.png
pretty_table: true
toc:
  beginning: true
---

# Intro
花了两天时间,终于把KMP和BM算法弄懂了. 本编文章将介绍KMP和BM相关算法的实现以及过程,并引入`Google Benchmark`作初步性能测试.  
本编不追求底层理论证明,只用图表和代码阐述算法实现及思想. 

## TL;DR
* 性能对比图

> `PATTERN`字符串只在`TEXT`的尾部, 中点处 出现两次, 稀疏匹配, 横坐标为搜索的`TEXT`串长度, [100,10M] 个字符, 纵坐标为`benchmark`消耗的cpu时间

* 短序列匹配(length<=5)  

pattern: `    std::string           short_pattern{"abca"};`  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/short_bm.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
    短序列稀疏匹配.  
</div>

* 中序列匹配(5<length<=30)  

pattern: `    std::string           medium_pattern{"HelloWWWorldHello"};`  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/medium_bm.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
    中序列稀疏匹配.  
</div>

* 长序列匹配(length>30)

pattern: `    std::string           long_pattern{"This isis long patternpattern string matched testThislongpatternpat"};`  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/long_bm.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
    长序列稀疏匹配.  
</div>


# KMP  

先讲`KMP`算法, 先要了解概念: 字符串的`真前缀`, `真后缀`.   
真前缀:  就是除了字符串`s`本身外的所有前缀, 比如串`abcda`, 则真前缀为`a`, `ab`, `abc`, `abcd`.   
真后缀: 同理, 就是除了s本身外的所有后缀, 比如串`abcda`, 则真后缀为`a`, `da`, `cda`, `bcda`.  

## 朴素算法  

先来看一下朴素匹配算法:  文本串`TEXT = goodgoogle`, 模式串`PAT=google`. 

{% highlight c++ linenos %}

std::vector<int> naive_match(std::string_view _text, std::string_view _pat)
{
    std::vector<int> pos;

    auto             text_len = _text.length();
    auto             pat_len  = _pat.length();

    for (int i = 0; i < text_len; i++)
    {
        bool matched = true;
        for (int j = 0; j < pat_len; j++)
        {
            if (_text[i + j] != _pat[j])
                matched = false;
        }

        if (matched)
            pos.push_back(i);
    }

    return pos;
}

int main()
{
    std::string TEXT = "goodgoogle.";
    std::string PAT  = "google";

    auto        pos  = naive_match(TEXT, PAT);
    if (!pos.empty())
    {
        for (const auto &p : pos)
        {
            std::cout << "Matched: " << TEXT.substr(p, PAT.length()) << std::endl;
        }
    }
    return 0;
}

{% endhighlight %}  

> 输出:
> Matched: google  


但这样无疑是非常慢的,而且重复匹配了很多可以跳过的步骤.  如图:  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/1.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>


<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/2.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>


<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/3.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>


<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/4.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>


<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/5.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>


`PAT[j]` 的索引 j  发生了回溯, 比如`1 -> 2`中, j从`3` 到了 `0`后又开始匹配,  这些回溯是可以被减少或取消的.  


>  第一次在`g` 失配后,2, 3 的匹配完全可以跳过直接到 4 .  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/1_4.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

所以就可以利用前缀信息, 对 `j` 的回溯进行优化,不需要每次从`PAT[0]`开始. 这样就引出了`next`数组.    
我们利用的信息是在`PAT`中的`前缀信息`, 仅与`PAT`有关. 这样构建的next数组称为`PAT`的前缀函数, 对于`next[i]`的值有:  

* 如果子串`PAT[0,i]`前有`相等的` 真前缀和真后缀,  则 `next[i]` 的值为最长的相等真前缀真后缀的长度.   
* 如果没有则为`0`.  

所以`abcdabcd`的`next`数组:  

| j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |
|    PAT[j]    | a | b | c | d | a | b | c | d |
|    next[j]   | 0 | 0 | 0 | 0 | 1 | 2 | 3 | 4 |

`google`的`next`数组:  

| j | 0 | 1 | 2 | 3 | 4 | 5 |  
| :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |
|    PAT[j]    | g | o | o | g | l | e |
|    next[j]   | 0 | 0 | 0 | 1 | 0 | 0 |

`aaaaaa`的`next`数组:  

| j | 0 | 1 | 2 | 3 | 4 | 5 |  
| :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |
|    PAT[j]    | a | a | a | a | a | a |
|    next[j]   | 0 | 1 | 2 | 3 | 4 | 5 |

## next数组  

那要如何来计算`next`数组呢?   观察上述 `next`数组的变化:  
* `next[i]` 的值是 记录了 相等的真前缀 `长度` 和 `位置` , 我们每次只需要和`next[i-1]` 比对就可以了,不需要从头开始构造 前缀字符串 来比对.  
*  `next[i]` 的值要么是 `next[i-1]`  , 要么是 `next[i-1]` 增减 `1` .   

那就对`PAT` 从前开始遍历, 比较`PAT[i] == PAT[ next [ i-1 ] ] `, 相等则意味着 存在 更长的前缀. 不相等则回溯 `next[i-1]`.  `next[i-1]` 等于0 则无需回溯.  

{% highlight c++ linenos %}
auto cal_next = [](std::string_view _pat)
{
    auto                      pat_len = _pat.length();
    std::vector<unsigned int> next(pat_len, 0);

    for (int i = 1; i < pat_len; i++) // 从 1 开始遍历, next[0] === 0
    {
        int j = next[i - 1];

        while (j > 0 && _pat[i] != _pat[j])
            j = next[j - 1];

        if (_pat[i] == _pat[j])
            j++;

        next[i] = j;
    }

    return next;
};

{% endhighlight %}

那有了`next`数组后我们有两种KMP的实现:    
1.	 对朴素算法改进, 每次 `PAT[j]` 回溯时 采用`next[j]`的值, 减少匹配次数. 
2.	构建一个字符串 `ALL = PAT + '#' + TEXT `,  因为 `next` 记录的是相等的前后缀值. 如果 `TEXT`中有`PAT`的话, 我们对`ALL` 求出的next中就会有和`PAT.length()` 相等的值. 必须用`#` 在两个字符串中均不存在的字符来分割.  

对于 `1.` 的代码:  
{% highlight c++ linenos %}  


auto kmp(std::string_view _text, std::string_view _pat)
{
    std::vector<int> pos;

    auto             next     = cal_next(_pat);

    auto             text_len = _text.length();
    auto             pat_len  = _pat.length();

    for (int i = 0, j = 0; i < text_len; i++)
    {
        
        while (j > 0 && _text[i] != _pat[j])    // 只要发生不匹配, 则回溯 匹配前缀长度 
            j = next[j - 1];

        if (_text[i] == _pat[j])
            j++;    //记录下 已经相等的 匹配前缀长度 

        if (j == pat_len) // 相等比较后, 保存 TEXT 处 PAT 的起点值. 
            pos.push_back(i - pat_len + 1);
    }

    return pos;
}

{% endhighlight %}  


对于 `2.` 的代码, 出自: [https://oi-wiki.org/string/kmp/#%E6%9C%80%E7%BB%88%E7%AE%97%E6%B3%95:~:text=%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82-,%E8%80%8C%E4%B8%94%E8%AF%A5%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%87%BA%E4%BA%BA%E6%84%8F%E6%96%99%E7%9A%84%E7%9F%AD%E4%B8%94%E7%9B%B4%E8%A7%82,-%EF%BC%9A]()  


{% highlight c++ linenos %}

auto kmp_io(std::string_view _text, std::string_view _pat)
{
    std::vector<int> pos;

    std::string      text{_text}, pat{_pat};

    std::string      all     = pat + "#" + text;	//构造一个长字符串
    auto             all_len = all.length();
    auto             pat_len = pat.length();

    auto             next    = cal_next(all);

    for (int i = pat_len  + 1; i < all_len; i++)
    {
        if (next[i] == pat_len)
        {
            pos.push_back(i - 2 * pat_len);
        }
    }
    return pos;
}

{% endhighlight %}

# Boyer-Moore  
> KMP 适合处理`PAT`中存在许多重复序列的情况, 而且适合需要逐字符处理的实时性场景. BM相比KMP利用后缀匹配的形式获取更多的信息量和更大的`TEXT`跳转, 一般情况下 BM 性能会优于 KMP.   

> 对于`TEXT` 迭代量我们声明为`∆i`, `TEXT`的长度声明为`TEXT_len`, `PAT`长度声明为`PAT_len`.      



对于BM, 需要学习 `坏字符` 和 `好后缀` 的概念. 
* 坏字符, 也就是`TEXT`中失配于`PAT`处的那个字符.  
* 好后缀, 就是`TEXT`失配于`PAT`处的,  `TEXT`和`PAT`公共相等的后缀字符串.   

如图:  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/bad_good.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

## 坏字符规则  
对于坏字符规则, 我们利用`坏字符表` 来构建 `TEXT`的迭代跳转量`∆i`.    
对于`∆i` 的取值我们分为两种情况: 

* `Bad Char` 在`PAT` 左侧中, 即`Bad Char` 在`PAT`失配位置之前, 取`PAT_len-1-p = last - p`, `p`为`Bad Char` 在`PAT` 中出现的最后一次 `索引`, `last` 为`PAT`的最后一个字符的`索引`:  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/badchar_p.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

***特别的***, 当失配字符时首字符时, 一样`last-p` .   


<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/badchar_head.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

* `Bad Char` 不在`PAT`左侧中, 直接取得`PAT_len`  

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/bm_kmp/bad_patlen.jpeg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

一句话概括: `∆i = PAT最后一个字符索引 - 坏字符最后一次索引`, 如果`PAT` 前缀中没有坏字符取`pat_len`.   

### 二维坏字符表  

理解了逻辑我们就可以编写计算`BadChar`表格的代码了, 先从容易理解的二维`BadChar_table`入手.  
*  对于`TEXT`中可能出现的所有字符, 假设来自ASCII集合, 则令`行`为256, 对应每个字符的ASCII值.  
* `列`为`PAT`的每个字符.   

